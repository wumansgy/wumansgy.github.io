<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个简单区块的实现]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%8C%BA%E5%9D%97%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简单区块实现区块链技术如今已经越来越成熟，但是我们怎么深入到本质用技术的眼光来看待区块链技术，见名知意，区块链的意思就是用链条把区块链接起来，那我们先用代码来看一下，今天我们用go语言来简单的实现一个区块并打印。 我们可以先来理一下思路，我们想要实现一个区块该怎么办，思路理好然后再来代码一步一步实现 创建一个结构体来保存一个区块的信息 //大概包括时间戳，数据，前哈希，本哈希这几个数据 创建第一个区块并给其中的数据赋值，也就相当于一个创世块，注意这里创世块的前哈希传一个空值就可以 给这个区块的数据处理一下然后加密得到本区块的哈希 主函数里面打印看一下本区块的哈希 //哈希用16进制打印 大概这样思路就可以理顺了，然后我们就可以一步一步实现了 1：第一步创建一个区块结构体 1234567type Block struct &#123; //创建一个区块结构体 Timer int64 //时间戳 Data []byte //数据 prevHash []byte //前一个区块的哈希值 Hash []byte //本区块的哈希值&#125; 区块结构体创建完成，继续下一步 2：创建第一个区块 1234func Firstblosk() *Block &#123; //创建第一个区块信息，相当于一个创始块 firstblock := NewBlock("This is firstblock", []byte&#123;&#125;) //传入参数，返回结构体指针类型 return firstblock //返回的是结构体指针类型&#125; 123456789func NewBlock(data string, prevhash []byte) *Block &#123; //创建区块的函数 block1 := Block&#123;&#125; //创建一个区块结构体 block1.Timer = time.Now().Unix() //得到时间 block1.Data = []byte(data) //传入数据参数 block1.prevHash = prevhash //前一个哈希值为传入的数据 block1.setHash() //setHash 方法加密得到自己的hash return &amp;block1 //返回区块指针&#125; 用来创建第一个区块 3：给区块信息数据处理 123456func (block *Block) setHash() &#123; time := []byte(strconv.FormatInt(block.Timer, 10)) //将区块的时间转为字符切片类型，方便加密 heards := bytes.Join([][]byte&#123;time, block.Data, block.prevHash&#125;, []byte&#123;&#125;) //将时间，数据，前一个哈希拼接一下 hash := sha256.Sum256(heards) //用sha256包的Sum256函数加密 block.Hash = hash[:] //加密后的直接赋值给本哈希&#125; 4:主函数里面打印看一下本区块的哈希 //哈希用16进制打印 12345func main() &#123; firstblock := Firstblosk() fmt.Printf("%x",string(firstblock.Hash)) //16进制打印&#125; 这样一个简单的区块就创建成功了，我们把所有代码连接起来然后来看一下打印结果 123456789101112131415161718192021222324252627282930313233343536373839404142package main/*一个简单的区块创建实现*/import ( "time" "strconv" "bytes" "crypto/sha256" "fmt")type Block struct &#123; //创建一个区块结构体 Timer int64 //时间戳 Data []byte //数据 prevHash []byte //前一个区块的哈希值 Hash []byte //本区块的哈希值&#125;func (block *Block) setHash() &#123; time := []byte(strconv.FormatInt(block.Timer, 10)) //将区块的时间转为字符切片类型，方便加密 heards := bytes.Join([][]byte&#123;time, block.Data, block.prevHash&#125;, []byte&#123;&#125;) //将时间，数据，前一个哈希拼接一下 hash := sha256.Sum256(heards) //用sha256包的Sum256函数加密 block.Hash = hash[:] //加密后的直接赋值给本哈希&#125;func Firstblosk() *Block &#123; //创建第一个区块信息，相当于一个创始块 firstblock := NewBlock("This is firstblock", []byte&#123;&#125;) //传入参数，返回结构体指针类型 return firstblock //返回的是结构体指针类型&#125;func NewBlock(data string, prevhash []byte) *Block &#123; //创建区块的函数 block1 := Block&#123;&#125; //创建一个区块结构体 block1.Timer = time.Now().Unix() //得到时间 block1.Data = []byte(data) //传入数据参数 block1.prevHash = prevhash //前一个哈希值为传入的数据 block1.setHash() //setHash 方法加密得到自己的hash return &amp;block1 //返回区块指针&#125;func main() &#123; firstblock := Firstblosk() fmt.Printf("%x",string(firstblock.Hash)) //16进制打印&#125; 我们来看一下哈希打印结果 这样一个简单的区块就实现了，那么如果要实现一个简单的区块链呢？其实也按照这样的思路写下去也很容易实现，记住：区块链的本区块的哈希是下一个区块的前哈希，这样链接，下一章我们将讲解一个简单的区块链实现。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言简单排序之冒泡和插入排序]]></title>
    <url>%2F2018%2F09%2F01%2Fgo%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[编程即数学，在编程中也会遇到很多的数学问题的集合，今天我们来讲解一下编程中最常见的冒泡排序，以及冒泡排序之后的插入排序 1：冒泡排序：见名知意，冒泡在我们生活当中可以有哪些常见的事物呢，比如在生活当中，大家都见到过烧开水的状态，那么水中的气泡就会不断的往上面漂浮，应用物理学上的知识来讲就是气泡的质量比较轻，在水中有浮力，就会不断的上浮，那么我们应该怎样应用到编程中的冒泡排序呢，我们先来看一段代码，然后慢慢分析 12345678910111213141516171819package mainimport "fmt"//func main() &#123; arr := [10]int&#123;9, 1, 5, 6, 3, 7, 10, 8, 2, 4&#125; //先定义一个乱序数组 //冒泡排序 for i := 0; i &lt; 10-1; i++ &#123; //外面的循环用来循环次数 for j := 0; j &lt; 10-1-i; j++ &#123; //里面的循环用来循环 每次对比到哪里 if arr[j] &gt; arr[j+1] &#123; //数据交换 arr[j], arr[j+1] = arr[j+1], arr[j] //go语言的多个数据交换格式 //temp := arr[j] //普通数据交换格式 //arr[j] = arr[j+1] //arr[j+1] = temp &#125; &#125; &#125; fmt.Println(arr)&#125; 我们看到这个代码和这张图片，在图片中我们只写了前面几次，先来看第一次，第一个元素和第二个相比4比2大，如果第一个元素比第二个大那么就交换一下，然后第二个元素和第三个相比，如果大就交换，然后第三第四相比，第四第五相比，一直比到最后一个和倒数第一个，有没有发现这样比一次就能确定一个最大的数，而且最大的数是放在最后一个元素里面的，这样一次就是外面的外循环 1for i := 0; i &lt; 10-1; i++ &#123; //这句话就是外面的循环 然后确定第一个最大的放最后一个，那么我们然后怎么办呢 ，然后我们当然继续下一次对比然后再确定一个第二大的放在倒数第二的位置啊，最大的确定下来后，我们继续从第一个开始遍历，但是这次遍历要注意了，不需要遍历到最后一个元素，而只需遍历到倒数第二个就行了，这是为什么呢，因为最后一个元素已经确定下来是最大的了，所以就不需要对比了，我们来看内循环 12for j := 0; j &lt; 10-1-i; j++ &#123; //里面的循环用来循环 每次对比到哪里//这里的判断条件是 小于10-1-i，i是什么呢，就是外循环的次数，所以只需要对比到10-1-i就行 然后内循环每次对比相邻的两个元素，如果前面大于后面的那么就交换， 12345//数据交换 arr[j], arr[j+1] = arr[j+1], arr[j] //go语言的多个数据交换格式 //temp := arr[j] //普通数据交换格式 //arr[j] = arr[j+1] //arr[j+1] = temp 这里面数据交换 有两种格式，第一种就是GO语言里面的简单交换格式，第二种是常见的交换数据格式，需要定义一个临时变量 然后可以打印出来数组，就变成从小到大的升序数组了， 那么如果要变成降序排序怎么改呢？ 来看这句话 1if arr[j] &gt; arr[j+1] &#123; 我们只需要把这里的大于号改成小于号就行啦 不喜勿喷，谢谢哈哈插入排序后续]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>排序问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言中的面向对象，接口类型，工厂设计模式解读]]></title>
    <url>%2F2018%2F09%2F01%2Fgo%E8%AF%AD%E8%A8%80%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式： 定义一个用于创建对象的接口，让子类决定实例化哪一个类抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类个人觉得这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。工厂方法模式 抽象工厂模式针对的是一个产品等级结构 针对的是面向多个产品等级结构一个抽象产品类 多个抽象产品类可以派生出多个具体产品类 每个抽象产品类可以派生出多个具体产品类一个抽象工厂类，可以派生出多个具体工厂类 一个抽象工厂类，可以派生出多个具体工厂类每个具体工厂类只能创建一个具体产品类的实例 每个具体工厂类可以创建多个具体产品类的实例加减乘除四则运算器工厂模式举例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport "fmt"type operation struct&#123; //定义一个父类两个数据 num1 float64 num2 float64&#125;type operationAdd struct&#123; //加法子类 operation&#125;func (op *operationAdd)getresult()float64&#123; //加法类的方法 return op.num1+op.num2&#125;type operationSub struct&#123; //减法子类 operation&#125;func (sub *operationSub)getresult()float64&#123; //减法类的方法 return sub.num1-sub.num2&#125;type operationMult struct&#123; //乘法子类 operation&#125;func (mult *operationMult)getresult()float64&#123; return mult.num1*mult.num2&#125;type operationDivi struct&#123; operation&#125; //除法子类func (divi *operationDivi)getresult()float64&#123; return divi.num1/divi.num2&#125;type operationer interface&#123; //定义接口 getresult() float64 //加法的方法&#125;type operationfactor struct &#123; //operation //用于创建对象的类，工厂模式&#125;func (op *operationfactor)creatoperation(ope string,num1 float64,num2 float64)float64&#123; //用于构件对象类 var result float64 switch ope &#123; case "+": add:=&amp;operationAdd&#123;operation&#123;num1,num2&#125;&#125; //按照传过来的符号来创建相应的对象 result=operationwho(add) //传递给多态的函数，直接调用 case "-": sub:=&amp;operationSub&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(sub) case "*": mult:=&amp;operationMult&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(mult) case "/": divi:=&amp;operationDivi&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(divi) &#125; return result&#125;func operationwho(i operationer)float64&#123; return i.getresult() //此处为创建一个多态的函数&#125;func main()&#123; //m:=&amp;operationAdd&#123;operation&#123;3,4&#125;&#125; //var iop operationer //iop=m //sum:=iop.getresult() //fmt.Println(sum) var op1 operationfactor //直接创建工厂类对象 sum:=op1.creatoperation("+",9,6) //直接调用工厂类的方法 fmt.Println(sum) var op2 operationfactor sub:=op2.creatoperation("-",9,8) fmt.Println(sub) var op3 operationfactor mult:=op3.creatoperation("*",3,4) fmt.Println(mult) var op4 operationfactor div:=op4.creatoperation("/",9,10) fmt.Println(div)&#125; 在上面的例子当中，如果对面向对象没有接触的话可能会有一些不好理解，在go语言当中面向对象可能和别的语言有一些不同，go语言是利用匿名字段来实现继承，在上面的例子中多态函数的实现可以让函数调用更加方便，比如每个结构体类都有10几个甚至更多的函数，那么直接都把这些函数封装在多态的函数里面，那么每次调用直接传递一个结构体类给多态函数就直接全部调用了，这样就是很方便的]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
</search>
