<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[爬取豆瓣评分Demo]]></title>
    <url>%2F2018%2F09%2F05%2F%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E8%AF%84%E5%88%86Demo%2F</url>
    <content type="text"><![CDATA[爬虫爬虫简介： 是一个程序，用来获取指定网站数据信息。 明确 url 。确定爬取对象 发送请求。获取服务器响应数据。 解析数据，提取有用数据内容。 保存、分析数据结果。 今天我们用go并发来简单写一个小Demo来爬取一下豆瓣评分网站的数据 首先来思路分析一下该怎么做： 明确 url。找出url之间的一些小规律，比如豆瓣的url规律如下 1234567https://movie.douban.com/top250?start=0&amp;filter= 1https://movie.douban.com/top250?start=25&amp;filter= 2 https://movie.douban.com/top250?start=50&amp;filter= 3https://movie.douban.com/top250?start=75&amp;filter= 4 之间的规律很好找 待提取字符特性： 123//电影名称： &lt;img width=&quot;100&quot; alt=&quot;（电影名称）&quot; src=&quot; —— `&lt;img width=&quot;100&quot; alt=&quot;(?s:(.*?))&quot; src=&quot;` 或 (.*?)// 评分：&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;（评分）&lt;/span&gt;//评价人数： &lt;span&gt;（评价人数）人评价&lt;/span&gt; —— `&lt;span&gt;(\d*?)人评价&lt;/span&gt;` 提示用户指定爬取起始、终止页 封装 doWork 函数， 按起始、终止页面循环爬取网页数据 组织每个网页的 url。 下一页 = +25 封装函数 HttpGetDB（url）result，err { http.Get(url), resp.Body.Read(buf), n==0 break, result+= string(buf[:n}) } 爬取网页的所有数据 通过result 返回给调用者。 解析、编译正则表达式 —— 提取 “电影名称”fileNames 传出的是[][]string ， 下标为【1】是不带匹配参考项。 解析、编译正则表达式 —— 提取 “评分”传出的是[][]string ， 下标为【1】是不带匹配参考项。 解析、编译正则表达式 —— 提取 “评价人数”传出的是[][]string ， 下标为【1】是不带匹配参考项。 封装函数，将上述内容写入文件。save2File（ [][]string） //Create() //n = len(fileNames) //for 循环 一次写入一条电影信息。 f.writeString() 创建并发go程 提取所有网页数据。 创建阻止主go程提取退出的 channel ， SpiderPageDB() 末尾处，写channel doWork 中，添加新 for ，读channel 代码实现：首先可以封装一个函数来爬取多少页到多少页，并且每一页构造一个go程 123456789101112func doWork(start, end int) &#123; page := make(chan int) // 循环创建多个goroutine，提高爬取效率 for i:=start; i&lt;=end; i++ &#123; go SpiderPageDB(i, page) &#125; // 循环读取 channel， 协调主、子go程调用顺序 for i:=start; i&lt;=end; i++ &#123; fmt.Printf(&quot;第%d页爬取完成\n&quot;, &lt;-page) &#125;&#125; 获取每一页的数据函数 123456789101112131415161718192021func HttpGetDB(url string) (result string, err error) &#123; resp, err1 := http.Get(url) if err1 != nil &#123; err = err1 return &#125; defer resp.Body.Close() buf := make([]byte, 4096) for &#123; n, err2 := resp.Body.Read(buf) if n == 0 &#123; break &#125; if err2 != nil &amp;&amp; err2 != io.EOF &#123; err = err2 return &#125; result += string(buf[:n]) &#125; return&#125; 得到每一个数据然后分析数据解析数据 123456789101112131415161718192021222324252627282930func SpiderPageDB(i int, page chan&lt;- int) &#123; url := &quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa((i-1)*25) + &quot;&amp;filter=&quot; result, err := HttpGetDB(url) if err != nil &#123; fmt.Println(&quot;HttpGetDB err:&quot;, err) return &#125; // 编译、解析正则表达式 —— 电影名 ret1 := regexp.MustCompile(`&lt;img width=&quot;100&quot; alt=&quot;(?s:(.*?))&quot; src=&quot;` ) // 提取有效信息 fileNames := ret1.FindAllStringSubmatch(result, -1) // 编译、解析正则表达式 —— 分数 pattern := `&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;` ret2 := regexp.MustCompile(pattern ) // 提取有效信息 fileScore := ret2.FindAllStringSubmatch(result, -1)/* for _, one := range fileScore &#123; fmt.Println(&quot;fileName:&quot;, one[1]) &#125;*/ // 编译、解析正则表达式 —— 评分人数 ret3 := regexp.MustCompile(`&lt;span&gt;(\d*?)人评价&lt;/span&gt;`) // 提取有效信息 peopleNum := ret3.FindAllStringSubmatch(result, -1) // 写入到一个文件中 save2file(i, fileNames, fileScore, peopleNum) page &lt;- i // 写入channel ，协调主go程与子go程调用顺序。&#125; 最后保存数据到文件中 123456789101112131415161718192021func save2file(idx int, fileNames, fileScore, peopleNum [][]string) &#123; // 组织保存文件路径及名程 path := &quot;D:/ecec/第&quot; + strconv.Itoa(idx) + &quot;页.txt&quot; f, err := os.Create(path) if err != nil &#123; fmt.Println(&quot;Create err:&quot;, err) return &#125; defer f.Close() // 获取 一个网页中的条目数 —— 25 n := len(fileNames) // 写一行标题 f.WriteString(&quot;电影名称&quot; + &quot;\t&quot; + &quot;评分&quot; + &quot;\t&quot; + &quot;评价人数&quot; + &quot;\n&quot;) // 依次按序写入电影相关条目。 for i:=0; i&lt;n; i++ &#123; f.WriteString(fileNames[i][1] + &quot;\t&quot; + fileScore[i][1] + &quot;\t&quot; + peopleNum[i][1] + &quot;\n&quot;) &#125;&#125; 最后直接在main里面就可以调用 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( "fmt" "strconv" "net/http" "io" "regexp" "os")func HttpGetDB(url string) (result string, err error) &#123; resp, err1 := http.Get(url) if err1 != nil &#123; err = err1 return &#125; defer resp.Body.Close() buf := make([]byte, 4096) for &#123; n, err2 := resp.Body.Read(buf) if n == 0 &#123; break &#125; if err2 != nil &amp;&amp; err2 != io.EOF &#123; err = err2 return &#125; result += string(buf[:n]) &#125; return&#125;func SpiderPageDB(i int, page chan&lt;- int) &#123; url := "https://movie.douban.com/top250?start=" + strconv.Itoa((i-1)*25) + "&amp;filter=" result, err := HttpGetDB(url) if err != nil &#123; fmt.Println("HttpGetDB err:", err) return &#125; // 编译、解析正则表达式 —— 电影名 ret1 := regexp.MustCompile(`&lt;img width="100" alt="(?s:(.*?))" src="` ) // 提取有效信息 fileNames := ret1.FindAllStringSubmatch(result, -1) // 编译、解析正则表达式 —— 分数 pattern := `&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;` ret2 := regexp.MustCompile(pattern ) // 提取有效信息 fileScore := ret2.FindAllStringSubmatch(result, -1)/* for _, one := range fileScore &#123; fmt.Println("fileName:", one[1]) &#125;*/ // 编译、解析正则表达式 —— 评分人数 ret3 := regexp.MustCompile(`&lt;span&gt;(\d*?)人评价&lt;/span&gt;`) // 提取有效信息 peopleNum := ret3.FindAllStringSubmatch(result, -1) // 写入到一个文件中 save2file(i, fileNames, fileScore, peopleNum) page &lt;- i // 写入channel ，协调主go程与子go程调用顺序。&#125;func save2file(idx int, fileNames, fileScore, peopleNum [][]string) &#123; // 组织保存文件路径及名程 path := "C:/exec/第" + strconv.Itoa(idx) + "页.txt" f, err := os.Create(path) if err != nil &#123; fmt.Println("Create err:", err) return &#125; defer f.Close() // 获取 一个网页中的条目数 —— 25 n := len(fileNames) // 写一行标题 f.WriteString("电影名称" + "\t" + "评分" + "\t" + "评价人数" + "\n") // 依次按序写入电影相关条目。 for i:=0; i&lt;n; i++ &#123; f.WriteString(fileNames[i][1] + "\t" + fileScore[i][1] + "\t" + peopleNum[i][1] + "\n") &#125;&#125;func doWork(start, end int) &#123; page := make(chan int) // 循环创建多个goroutine，提高爬取效率 for i:=start; i&lt;=end; i++ &#123; go SpiderPageDB(i, page) &#125; // 循环读取 channel， 协调主、子go程调用顺序 for i:=start; i&lt;=end; i++ &#123; fmt.Printf("第%d页爬取完成\n", &lt;-page) &#125;&#125;func main() &#123; var start, end int fmt.Print("请输入爬取起始页面（&gt;=1）:") fmt.Scan(&amp;start) fmt.Print("请输入爬取终止页面（&gt;=start）:") fmt.Scan(&amp;end) doWork(start, end)&#125;]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>go并发简单爬虫Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符二进制转换]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%AD%97%E7%AC%A6%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[字符二进制转换运用位操作左移和右移来实现字符二进制转换的一个源码（自己也可以去实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package Btosimport ( "errors" "regexp")const ( zero = byte('0') one = byte('1') lsb = byte('[') // left square brackets rsb = byte(']') // right square brackets space = byte(' '))var uint8arr [8]uint8// ErrBadStringFormat represents a error of input string's format is illegal .var ErrBadStringFormat = errors.New("bad string format")// ErrEmptyString represents a error of empty input string.var ErrEmptyString = errors.New("empty string")func init() &#123; uint8arr[0] = 128 uint8arr[1] = 64 uint8arr[2] = 32 uint8arr[3] = 16 uint8arr[4] = 8 uint8arr[5] = 4 uint8arr[6] = 2 uint8arr[7] = 1&#125;// append bytes of string in binary format.func appendBinaryString(bs []byte, b byte) []byte &#123; var a byte for i := 0; i &lt; 8; i++ &#123; a = b b &lt;&lt;= 1 b &gt;&gt;= 1 switch a &#123; case b: bs = append(bs, zero) default: bs = append(bs, one) &#125; b &lt;&lt;= 1 &#125; return bs&#125;// ByteToBinaryString get the string in binary format of a byte or uint8.func ByteToBinaryString(b byte) string &#123; buf := make([]byte, 0, 8) buf = appendBinaryString(buf, b) return string(buf)&#125;// BytesToBinaryString get the string in binary format of a []byte or []int8.func BytesToBinaryString(bs []byte) string &#123; l := len(bs) bl := l*8 + l + 1 buf := make([]byte, 0, bl) buf = append(buf, lsb) for _, b := range bs &#123; buf = appendBinaryString(buf, b) buf = append(buf, space) &#125; buf[bl-1] = rsb return string(buf)&#125;// regex for delete useless string which is going to be in binary format.var rbDel = regexp.MustCompile(`[^01]`)// BinaryStringToBytes get the binary bytes according to the// input string which is in binary format.func BinaryStringToBytes(s string) (bs []byte) &#123; if len(s) == 0 &#123; panic(ErrEmptyString) &#125; s = rbDel.ReplaceAllString(s, "") l := len(s) if l == 0 &#123; panic(ErrBadStringFormat) &#125; mo := l % 8 l /= 8 if mo != 0 &#123; l++ &#125; bs = make([]byte, 0, l) mo = 8 - mo var n uint8 for i, b := range []byte(s) &#123; m := (i + mo) % 8 switch b &#123; case one: n += uint8arr[m] &#125; if m == 7 &#123; bs = append(bs, n) n = 0 &#125; &#125; return&#125;]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>二进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言贪食蛇和c语言区别]]></title>
    <url>%2F2018%2F09%2F05%2Fgo%E8%AF%AD%E8%A8%80%E8%B4%AA%E9%A3%9F%E8%9B%87%E5%92%8Cc%E8%AF%AD%E8%A8%80%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[CSDN博客链接 GO贪食蛇小Demo利用go语言写贪食蛇游戏那么就会利用面向对象的思想来写一下，创造蛇身体对象，然后写出来，go语言写的时候我们需要调用一个c语言写的一个包，go语言可以直接调用调用c语言的函数，很方便简洁，我们先来看一下我自己写的C语言的一个包 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Clib/*#include &lt;windows.h&gt;#include &lt;conio.h&gt;// 使用了WinAPI来移动控制台的光标void gotoxy(int x,int y)&#123; COORD c; c.X=x,c.Y=y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),c);&#125;// 从键盘获取一次按键，但不显示到控制台int direct()&#123; return _getch();&#125;//去掉控制台光标void hideCursor()&#123; CONSOLE_CURSOR_INFO cci; cci.bVisible = FALSE; cci.dwSize = sizeof(cci); SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cci);&#125;*/import "C" // go中可以嵌入C语言的函数//设置控制台光标位置func GotoPostion(X int, Y int) &#123; //调用C语言函数 C.gotoxy(C.int(X), C.int(Y))&#125;//无显获取键盘输入的字符func Direction() (key int) &#123; key = int(C.direct()) return&#125;//设置控制台光标隐藏func HideCursor() &#123; C.hideCursor()&#125; 这个包把一些需要用到c语言的函数写进来，调用c语言的函数需要用到c语言的环境，别忘记自己电脑上要装c语言的环境奥，我们来看一下这个目录结构 首先我们的代码是放在GoCode里面下面的src目录下面，Clib里面是自己写的C语言的一个包，贪食蛇和Clib是同级别目录，在这里我们用的是goland编译器，编译器这里可以自己选择，我们编译的时候就不能单个文件编译了，因为需要调用自己的包，所以要选择多文件编译如图 我自己用的goland编译的时候需要改一下改成Directory 然后目录选到所在目录的src目录，然后设置好后就可以直接编译运行啦，当然也可以直接命令行编译运行 如图，我们可以在所在目录下面直接go build ./这样就是生成可执行文件.exe的，也可以直接使用go run命令直接编译运行， 感兴趣的小伙伴可以自己去试试啦 下面来看一下go语言写的代码，（可以自己去完善一下奥，比如加入等级，加入障碍物，蛇的速度都是自己可以调节的奥） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package mainimport ( "Clib" "fmt" "os" "math/rand" "time")const wide int = 20const high int = 20var key int64 = 1 //关卡var food1 food //定义一个全局食物结构体//var size int = 2 //定义一个全局蛇的长度var score int = 0 //定义一个全局分数var dx int = 0var dy int = 0 //蛇的偏移量var barr1 barrier //障碍物结构体var c cake //定义一个蛋糕var FLAG bool=truetype postion struct &#123; x int y int //父类坐标&#125;type cake struct&#123; ca [5]postion&#125; //定义一个蛋糕type snake struct &#123; p [wide * high]postion size int dir byte&#125;type barrier struct &#123; barr [6]postion&#125; //障碍物结构体func (c *cake)setcake()&#123; x:=rand.Intn(wide-6)+3 y:=rand.Intn(high-6)+3 c.ca[0].x,c.ca[0].y=x,y c.ca[1].x,c.ca[1].y=x-1,y c.ca[2].x,c.ca[2].y= x-2,y c.ca[3].x,c.ca[3].y=x-1,y-1 c.ca[4].x,c.ca[4].y=x-1,y+1&#125;func (b *barrier)setbarrier()&#123; //定义一些随机障碍物 b.barr[0].x,b.barr[0].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1 b.barr[1].x,b.barr[1].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1 b.barr[2].x,b.barr[2].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1 //b.barr[3].x,b.barr[3].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1 //b.barr[4].x,b.barr[4].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1 //b.barr[5].x,b.barr[5].y=rand.Intn(wide-1)+1,rand.Intn(high-3)+1&#125;type food struct &#123; postion&#125; //食物func drawui(p postion, ch byte) &#123; Clib.GotoPostion(p.x*2+4, p.y+2+2) fmt.Fprintf(os.Stderr, "%c", ch)&#125;func (s *snake) initsnake() &#123; //蛇初始化 s.p[0].x = wide / 2 s.p[0].y = high / 2 s.p[1].x = wide/2 - 1 s.p[1].y = high / 2 //蛇头和第一个蛇结点初始化 s.dir = 'R' s.size=2 fmt.Fprintln(os.Stderr, ` #-----------------------------------------# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #-----------------------------------------#`) food1 = food&#123;postion&#123;rand.Intn(wide), rand.Intn(high) - 2&#125;&#125; //食物初始化 drawui(food1.postion, 'o') //画出食物 //go func()&#123; Clib.GotoPostion(46,19) fmt.Printf("正在进行第%d关，小心障碍物",key) //&#125;() go func()&#123; for&#123; time.Sleep(time.Second) num:=rand.Intn(10) if num==6&#123; c.setcake() break &#125; &#125; for i:=0;i&lt;len(c.ca);i++&#123; drawui(c.ca[i],'#') &#125; &#125;() //吃蛋糕的作用 go func()&#123; for i:=0;i&lt;len(barr1.barr);i++&#123; Clib.GotoPostion(barr1.barr[i].x,barr1.barr[i].y) drawui(barr1.barr[i],'!') &#125; &#125;() //打印出障碍物 go func() &#123; for &#123; switch Clib.Direction() &#123; case 72, 87, 119: if s.dir == 'D' &#123; break &#125; s.dir = 'U' case 65, 97, 75: if s.dir == 'R' &#123; break &#125; s.dir = 'L' case 100, 68, 77: if s.dir == 'L' &#123; break &#125; s.dir = 'R' case 83, 115, 80: if s.dir == 'U' &#123; break &#125; s.dir = 'D' case 32: s.dir = 'P' &#125; &#125; &#125;() //获取蛇跑的方向&#125;func (s *snake) playgame() &#123; //barr:=barrier&#123;postion&#123;rand.Intn(wide-5)+5,rand.Intn(high-5)+3&#125; //drawui(barr.postion,'p') for &#123; switch key &#123; case 1: time.Sleep(time.Second / 3) case 2:time.Sleep(time.Second / 5) case 3:time.Sleep(time.Second / 6) case 4:time.Sleep(time.Second / 7) case 5:time.Sleep(time.Second / 8) case 6:time.Sleep(time.Second / 9) //用来每增加一关蛇的速度加快 &#125; if s.dir == 'P' &#123; continue &#125; if s.p[0].x &lt; 0 || s.p[0].x &gt;= wide || s.p[0].y+2 &lt; 0 || s.p[0].y &gt;= high-2 &#123; Clib.GotoPostion(wide*3, high-3) FLAG=false return //如果蛇头碰墙就死亡 &#125; //if s.p[0].x==barr.postion.x&amp;&amp;s.p[0].y==barr.postion.y&#123; // Clib.GotoPostion(wide*3, high-3) // return //如果蛇头碰障碍物就死亡 //&#125; for i := 1; i &lt;s.size; i++ &#123; if s.p[0].x == s.p[i].x &amp;&amp; s.p[0].y == s.p[i].y &#123; Clib.GotoPostion(wide*3, high-3) FLAG=false return &#125; &#125; for j:=0;j&lt;len(barr1.barr);j++&#123; if s.p[0].x==barr1.barr[j].x&amp;&amp;s.p[0].y==barr1.barr[j].y&#123; Clib.GotoPostion(wide*3, high-3) FLAG=false return &#125; //碰到障碍物死亡 &#125; for m:=0;m&lt;len(c.ca);m++&#123; if s.p[0].x==c.ca[m].x&amp;&amp;s.p[0].y==c.ca[m].y&#123; s.size++ score++ &#125; if score &gt;= int(6+key*2) &#123; key++ return &#125; &#125; if s.p[0].x == food1.x &amp;&amp; s.p[0].y == food1.y &#123; s.size++ score++ if score &gt;= int(6+key*2) &#123; key++ return &#125; //画蛇 //food1 = food&#123;postion&#123;rand.Intn(wide), rand.Intn(high) - 2&#125;&#125; for &#123; flag := true temp := food&#123;postion&#123;rand.Intn(wide), rand.Intn(high) - 2&#125;&#125; for i := 1; i &lt; s.size; i++ &#123; if (temp.postion.x == s.p[i].x &amp;&amp; temp.postion.y == s.p[i].y) &#123; flag = false break &#125; &#125; for i:=0;i&lt;len(barr1.barr);i++&#123; if temp.postion.x==barr1.barr[i].x&amp;&amp;temp.postion.y==barr1.barr[i].y&#123; flag=false break &#125; &#125; if flag == true &#123; food1 = temp break &#125; &#125; drawui(food1.postion, 'o') &#125; switch s.dir &#123; case 'U': dx = 0 dy = -1 case 'D': dx = 0 dy = 1 case 'L': dx = -1 dy = 0 case 'R': dx = 1 dy = 0 &#125; lp := s.p[s.size-1] //蛇尾位置 for i := s.size - 1; i &gt; 0; i-- &#123; s.p[i] = s.p[i-1] drawui(s.p[i], '*') &#125; drawui(lp, ' ') //蛇尾画空格 s.p[0].x += dx s.p[0].y += dy //更新蛇头 drawui(s.p[0], 'O') //画蛇头 &#125;&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) var s snake for k:=1;k&lt;=6;k++&#123; //用来循环6次代表6个关卡，这里可以自己设置多少关卡 s.initsnake() //初始化 barr1.setbarrier() //障碍物 s.playgame() //玩游戏开始 if FLAG==false&#123; //这个代表蛇死亡返回的，所以这样就退出了 Clib.GotoPostion(46,21) fmt.Printf("你已死亡，第%d关总分：%d分",k, score) break &#125; Clib.GotoPostion(46,21) fmt.Printf("第%d关总分：%d分,稍等进入下一关",k, score) //key++ time.Sleep(time.Second * 5) //延时5秒 Clib.Cls() //每一关清屏一下 //size=2 score=0 //每一关分数置为0 &#125; time.Sleep(time.Second * 5) //延时5秒&#125;]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>小Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言贪食蛇实现]]></title>
    <url>%2F2018%2F09%2F05%2FC%E8%AF%AD%E8%A8%80%E8%B4%AA%E9%A3%9F%E8%9B%87%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[CSDN博客 贪食蛇小Demo我们先来看一下C语言的贪食蛇代码，相对于面向对象的的语言，C语言是一门面向过程的语言，C语言写出来的代码都是顺着平常的思路来一步一步实现的，我们先来看C语言的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;windows.h&gt;#include&lt;time.h&gt;//函数声明区void Pos(int x, int y);//光标位置设定void muban();//打印模板void initSnake();//蛇身的初始化void creatFood();//创建食物char reDirection();//识别方向int snakeMove();//蛇移动int crossWall();//不能穿墙int eatSelf();//不能吃自己typedef struct Snake//相当于蛇一个节点&#123; int x;//横坐标 int y;//纵坐标 struct Snake *next;&#125;snake;snake *head;//头指针snake *p;//用来遍历snake *food1;//用来标记的char status='L';//初始方向的状态，解决开始会动的问题int score=0;//分数int add=10;//一个食物的分int leap=0;//用来标志是否结束，0没有，1代表蛇死了代表结束了int endleap=0;//结束标志 1就是结束int sleepTime=500;void initSnake()//蛇身初始化，给定一个长度，用结构体表示是蛇的骨架，真正要显示出来是打印▇&#123; int i; snake *tail;//尾指针 tail=(snake*)malloc(sizeof(snake));//第一个节点/头结点 tail-&gt;x=30;//2的倍数，因为方块的长是两个单位 tail-&gt;y=10;//1个单位 tail-&gt;next=NULL; for(i=1;i&lt;=4;i++)//尾插法 &#123; head=(snake*)malloc(sizeof(snake));//申请一个节点 head-&gt;next=tail;//连接成链 head-&gt;x=30-2*i;//下一个节点的位置 head-&gt;y=10; tail=head; &#125; //遍历打印出来 while(tail!=NULL) &#123; Pos(tail-&gt;x,tail-&gt;y); printf("▇"); tail=tail-&gt;next; &#125;&#125;char reDirection()//识别用户按下的键值 保留方向值&#123; if(GetAsyncKeyState(VK_F7))//热键 &#123; if(sleepTime&gt;300)//最多减到300 &#123; sleepTime-=50;//每次减50 add++;//每次食物加1分 &#125; &#125; if(GetAsyncKeyState(VK_F8)) &#123; if(sleepTime&lt;800)//最多加到800 &#123; sleepTime+=50;//每次加50 add--;//每次食物减1分 &#125; &#125; if(GetAsyncKeyState(VK_UP)&amp;&amp;status!='D') status='U'; if(GetAsyncKeyState(VK_DOWN)&amp;&amp;status!='U') status='D'; if(GetAsyncKeyState(VK_LEFT)&amp;&amp;status!='R') status='L'; if(GetAsyncKeyState(VK_RIGHT)&amp;&amp;status!='L') status='R'; return status;&#125;void Pos(int x, int y)//设置光标位置，从哪里开始输出&#123; COORD pos;//表示一个字符在控制台屏幕上的坐标，左上角(0,0) HANDLE hOutput; pos.X = x; pos.Y = y; hOutput = GetStdHandle(STD_OUTPUT_HANDLE);//返回标准的输入、输出或错误的设备的句柄，也就是获得输入、输出/错误的屏幕缓冲区的句柄 SetConsoleCursorPosition(hOutput, pos);&#125;void creatFood()//创建食物&#123; snake *food;//创造一个食物 food=(snake*)malloc(sizeof(snake)); srand((unsigned int)time(NULL));//随着时间变化，产生不一样种子，就会得到没规律的食物 while(food-&gt;x%2!=0) &#123; food-&gt;x=rand()%56+2; &#125; food-&gt;y=rand()%23+1; //上面虽然解决了食物不会出现在城墙里，没有考虑食物出现在蛇本身里面 p=head;//用p来遍历 while(p!=NULL)//解决食物出现在蛇本身 &#123; if(food-&gt;x==p-&gt;x&amp;&amp;food-&gt;y==p-&gt;y) &#123; free(food); creatFood(); &#125; p=p-&gt;next; &#125; Pos(food-&gt;x,food-&gt;y); food1=food;//food1用来标记的作用 printf("▇"); Pos(70,20);//解决有光标闪烁的办法 printf("您的分数是:%d",score);&#125;void muban()&#123; int i; for(i=0;i&lt;=60;i+=2)//方块水平方向占两个单位 &#123; Pos(i,0); printf("▇");//上行 Pos(i,26); printf("▇");//下行 &#125; for(i=0;i&lt;=25;i+=1)//方块垂直方向占1个单位 &#123; Pos(0,i);//左列 printf("▇"); Pos(60,i);//右列 printf("▇"); &#125;&#125;int snakeMove()&#123; snake *nexthead; nexthead=(snake*)malloc(sizeof(snake)); if(status=='R')//向右走 &#123; nexthead-&gt;x=head-&gt;x+2; nexthead-&gt;y=head-&gt;y; if(nexthead-&gt;x==food1-&gt;x&amp;&amp;nexthead-&gt;y==food1-&gt;y)//吃掉了食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125;//吃掉了食物得创造 score=score+add; creatFood(); &#125; else//没有食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p-&gt;next-&gt;next!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125; Pos(p-&gt;next-&gt;x,p-&gt;next-&gt;y); printf(" ");//会带来一个光标闪烁 Pos(70,20);//解决办法 printf("您的分数是:%d",score); free(p-&gt;next); p-&gt;next=NULL; &#125; &#125; if(status=='L')//向左走 &#123; nexthead-&gt;x=head-&gt;x-2; nexthead-&gt;y=head-&gt;y; if(nexthead-&gt;x==food1-&gt;x&amp;&amp;nexthead-&gt;y==food1-&gt;y)//吃掉了食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125;//吃掉了食物得创造 score=score+add; creatFood(); &#125; else//没有食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p-&gt;next-&gt;next!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125; Pos(p-&gt;next-&gt;x,p-&gt;next-&gt;y); printf(" "); Pos(70,20);//解决办法 printf("您的分数是:%d",score); free(p-&gt;next); p-&gt;next=NULL; &#125; &#125; if(status=='U')//向上走 &#123; nexthead-&gt;x=head-&gt;x; nexthead-&gt;y=head-&gt;y-1; if(nexthead-&gt;x==food1-&gt;x&amp;&amp;nexthead-&gt;y==food1-&gt;y)//吃掉了食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125;//吃掉了食物得创造 score=score+add; creatFood(); &#125; else//没有食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p-&gt;next-&gt;next!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125; Pos(p-&gt;next-&gt;x,p-&gt;next-&gt;y); printf(" "); Pos(70,20);//解决办法 printf("您的分数是:%d",score); free(p-&gt;next); p-&gt;next=NULL; &#125; &#125; if(status=='D')//向下走 &#123; nexthead-&gt;x=head-&gt;x; nexthead-&gt;y=head-&gt;y+1; if(nexthead-&gt;x==food1-&gt;x&amp;&amp;nexthead-&gt;y==food1-&gt;y)//吃掉了食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125;//吃掉了食物得创造 score=score+add; creatFood(); &#125; else//没有食物 &#123; nexthead-&gt;next=head; head=nexthead; p=head;//p用来从头遍历，打印方块 while(p-&gt;next-&gt;next!=NULL) &#123; Pos(p-&gt;x,p-&gt;y); printf("▇"); p=p-&gt;next; &#125; Pos(p-&gt;next-&gt;x,p-&gt;next-&gt;y); printf(" "); Pos(70,20);//解决办法 printf("您的分数是:%d",score); free(p-&gt;next); p-&gt;next=NULL; &#125; &#125; Sleep(sleepTime);//蛇移动的速度，里面是毫秒，越大速度越慢 status=reDirection();//判别下方向先 if(crossWall()==1||eatSelf()==1) //exit(0);//直接把程序关闭了 endleap=1; return endleap;&#125;int crossWall()//判断蛇有没穿透墙&#123; if(head-&gt;x==0||head-&gt;y==0||head-&gt;x==60||head-&gt;y==25) leap=1; return leap;&#125;int eatSelf()//判断是否咬到了自己&#123; snake *q;//遍历的 q=head-&gt;next; while(q!=NULL) &#123; if(q-&gt;x==head-&gt;x&amp;&amp;head-&gt;y==q-&gt;y) leap=1; q=q-&gt;next; &#125; return leap;&#125;//打印食物的时候会出现光标，解决办法就是引开它int main()&#123; muban();//打印模板 initSnake();//初始化蛇 creatFood();//创建食物 while(1)//死循环，让蛇一直动起来，直到蛇死了 &#123; if(snakeMove()==1)//判断是否结束 &#123; Pos(70,23); printf("蛇死了"); system("pause");//用来暂停 Pos(70,24);//解决press any key to continue 在该地点打印 大家试下 break; &#125; &#125; printf("是否继续游戏，y or n：");//y 继续 if(getch()=='y')//重新游戏 &#123; //蛇一开始就死了，因为全局变量没有恢复原值，仍然保留上一局的值 status='L';//初始方向的状态，解决开始会动的问题 score=0;//分数 add=10;//一个食物的分 leap=0;//用来标志是否结束，0没有，1代表蛇死了代表结束了 endleap=0;//结束标志 1就是结束 sleepTime=500; system("cls");//清理屏幕 main();//自己调用自己 看不一样的编译器，vc6.0允许调用自己 &#125; if(getch()=='n') &#123; Pos(70,25);//定一个位置，再打印press exit(0);//退出程序 &#125; return 0;&#125;//蛇的速度变化，每个食物的分数增加//是否继续游戏//按键的作用 在C语言中，我们利用定义一个一个函数模块来实现蛇的基础实现，然后定义蛇的一个结构体，利用链表的知识来串联蛇身体，来让蛇身连接起来并走动起来。 /*go语言实现的贪食蛇请见博下一章/]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>小Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和Go相互调用]]></title>
    <url>%2F2018%2F09%2F05%2FC%E5%92%8CGo%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转载处：https://colobu.com/2018/08/28/c-and-go-calling-interaction/ C和Go相互调用C可以调用Go，并且Go可以调用C， 如果更进一步呢， C--&gt;Go--&gt;C 或者 Go--&gt;C--&gt;Go的调用如何实现？ 本文通过两个简单的例子帮助你了解这两种复杂的调用关系。本文不涉及两者之间的复杂的数据转换，官方文章C? Go? Cgo!、wiki/cgo和cmd/cgo有一些介绍。 Go–&gt;C–&gt;GoGo程序调用C实现的函数，然后C实现的函数又调用Go实现的函数。 1、首先，我们新建一个hello.go的文件： hello.go 1`package mainimport "C"import "fmt"//export HelloFromGofunc HelloFromGo() &#123; fmt.Printf("Hello from Go!\n")&#125;` 它定义了一个HelloFromGo函数，注意这个函数是一个纯的Go函数，我们定义它的输出符号为HelloFromGo。 2、接着我们新建一个hello.c的文件： 12345678#include &lt;stdio.h&gt;#include &quot;_cgo_export.h&quot;int helloFromC() &#123; printf(&quot;Hi from C\n&quot;); //call Go function HelloFromGo(); return 0;&#125; 这个c文件定义了一个C函数helloFromC,内部它会调用我们刚才定义的HelloFromGo函数。 这样，我们实现了C调用Go: C--&gt;Go,下面我们再实现Go调用C。 3、最后新建一个main.go文件： 123456789package main/*extern int helloFromC();*/import &quot;C&quot;func main() &#123; //call c function C.helloFromC()&#125; 它调用第二步实现的C函数helloFromC。 运行测试一下： 123$ go run .Hi from CHello from Go! 可以看到，期望的函数调用正常的运行。第一行是C函数的输出，第二行是Go函数的输出。 C–&gt;Go–&gt;C第二个例子演示了C程序调用Go实现的函数，然后Go实现的函数又调用C实现的函数。 1、首先新建一个hello.c文件： 12345#include &lt;stdio.h&gt;int helloFromC() &#123; printf(&quot;Hi from C\n&quot;); return 0;&#125; 它定义了一个纯C实现的函数。 2、接着新建一个hello.go文件： 1234567891011121314// go build -o hello.so -buildmode=c-shared .package main/*extern int helloFromC();*/import &quot;C&quot;import &quot;fmt&quot;//export HelloFromGofunc HelloFromGo() &#123; fmt.Printf(&quot;Hello from Go!\n&quot;) C.helloFromC()&#125;func main() &#123;&#125; 它实现了一个Go函数HelloFromGo,内部实现调用了C实现的函数helloFromC,这样我们就实现了Go--&gt;C。 注意包名设置为package main，并且增加一个空的main函数。 运行go build -o hello.so -buildmode=c-shared .生成一个C可以调用的库，这调命令执行完后会生成hello.so文件和hello.h文件。 3、最后新建一个文件夹，随便起个名字，比如main 将刚才生成的hello.so文件和hello.h文件复制到main文件夹，并在main文件夹中新建一个文件main.c: 123456789#include &lt;stdio.h&gt;#include &quot;hello.h&quot;int main() &#123; printf(&quot;use hello lib from C:\n&quot;); HelloFromGo(); return 0;&#125; 运行gcc -o main main.c hello.so生成可执行文件main, 运行main: 1234$ ./mainuse hello lib from C:Hello from Go!Hi from C 第一行输出来自main.c,第二行来自Go函数，第三行来自hello.c中的C函数，这样我们就实现了C--&gt;Go--C的复杂调用。 C--&gt;Go--&gt;C的状态变量我们来分析第二步中的一个特殊的场景， 为了下面我们好区分，我们给程序标记一下， 记为C1--&gt;Go--&gt;C2, C2的程序修改一下，加入一个状态变量a,并且函数helloFromC中会打印a的地址和值，也会将a加一。 123456#include &lt;stdio.h&gt;int a = 1;int helloFromC() &#123; printf(&quot;Hi from C: %p, %d\n&quot;, &amp;a, a++); return 0;&#125; 然后修改main.c程序,让它既通过Go嗲用C1.helloFromC,又直接调用C1.helloFromC,看看多次调用的时候a的指针是否一致，并且a的值是否有变化。 1234567891011121314#include &lt;stdio.h&gt;#include &quot;hello.h&quot;int main() &#123; printf(&quot;use hello lib from C:\n&quot;); // 1. 直接调用C函数 helloFromC(); // 2. 调用Go函数 HelloFromGo(); // 3. 直接调用C函数 helloFromC(); return 0;&#125; 激动人心的时候到了。我们不同的编译方式会产生不同的结果。 1、gcc -o main main.c hello.so 和第二步相同的编译方式，编译出main并执行， 因为hello.so中包含C1.helloFromC实现，所以可以正常执行。 123456./mainuse hello lib from C:Hi from C: 0x10092a370, 1Hello from Go!Hi from C: 0x10092a370, 2Hi from C: 0x10092a370, 3 可以看到a的指针是同一个值，无论通过Go函数改变还是通过C函数改变都是更改的同一个变量。 nm可以查看生成的main的符号： 1234567nm main U _HelloFromGo0000000100000000 T __mh_execute_header U _helloFromC0000000100000f10 T _main U _printf U dyld_stub_binder U代表这个符号是未定义的符号，通过动态库链接进来。 2、 gcc -o main main.c hello.so ../hello.c 我们编译的时候直接链接hello.c的实现，然后运行main: 123456./mainuse hello lib from C:Hi from C: 0x104888020, 1Hello from Go!Hi from C: 0x1049f7370, 1Hi from C: 0x104888020, 2 可以看到a是不同的两个变量。 nm可以查看生成的main的符号： 12345678nm main U _HelloFromGo0000000100000000 T __mh_execute_header0000000100001020 D _a0000000100000f10 T _helloFromC0000000100000ec0 T _main U _printf U dyld_stub_binder 可以看到_a是初始化的环境变量，_helloFromC的类型是T而不是U,代表它是一个全局的Text符号,这和上一步是不一样的]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>GO语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链以太坊相关资料]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[收集整理了一些免费区块链、以太坊技术开发相关的文件，有需要的可以下载，文件链接： web3.js API官方文档中文版：https://pan.baidu.com/s/1hOV9hEzi7hFxJCL4LTvC6g 以太坊官方文档中文版 ：https://pan.baidu.com/s/1ktODJKLMBmkOsi8MPrpIJA 以太坊白皮书中文版 ：https://pan.baidu.com/s/1bzAFnzJ35hlQxJ2J4Oj-Ow Solidity的官方文档中文版 ：https://pan.baidu.com/s/18yp9XjEqAHpiFm2ZSCygHw Truffle的官方文档中文版 ：https://pan.baidu.com/s/1y6SVd7lSLUHK21YF5FzIUQ C#区块链编程指南 ：https://pan.baidu.com/s/1sJPLqp1eQqkG7jmxqwn3EA 区块链技术指南： ：https://pan.baidu.com/s/13cJxAa80I6iMCczA04CZhg 精通比特币中文版： ：https://pan.baidu.com/s/1lz6te3wcQuNJm28rFvBfxg Node.js区块链开发 ：https://pan.baidu.com/s/1Ldpn0DvJ5LgLqwix6eWgyg geth使用指南文档中文版 ：https://pan.baidu.com/s/1M0WxhmumF_fRqzt_cegnag 以太坊DApp开发环境搭建-Ubuntu : https://pan.baidu.com/s/10qL4q-uKooMehv9X2R1qSA 以太坊DApp开发环境搭建-windows ：https://pan.baidu.com/s/1cyYkhIJIFuI2oyxM9Ut0eA 以太坊DApp开发私链搭建-Ubuntu : https://pan.baidu.com/s/1aBOFZT2bCjD2o0EILBWs-g 以太坊DApp开发私链搭建-windows ：https://pan.baidu.com/s/10Y6F1cqUltZNN99aJv9kAA 以太坊ganache CLI命令行参数详解：https://pan.baidu.com/s/1lnknFkwenacaeM4asOcBdg 使用truflle和infura部署以太坊合约：https://pan.baidu.com/s/1PTxSVff2vHSVUihYczRRqw IPFS安装部署与开发环境搭建-windows：https://pan.baidu.com/s/1bnhDvqCoOgAqEBZXMtVbRg EOS.IO教程： EOS智能合约与DApp开发入门：http://t.cn/RealN1W 以太坊教程： 以太坊DApp开发实战入门：http://t.cn/RmeEwxJ 以太坊node.js电商实战：http://t.cn/RnmDmaD C#开发以太坊区块链的教程：http://t.cn/ReYjplC java开发以太坊区块链的教程，web3j开发详解：http://t.cn/RrpULLJ PHP开发以太坊区块链的教程：http://t.cn/RrRAlAO python用web3.py开发以太坊区块链应用的教程：http://t.cn/RdXcpVD]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链中的双花问题]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%8F%8C%E8%8A%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[区块链中的“双花”问题我们举个简单的例子，比如你在商场刷卡买东西。这个行为面临三种危险： 首先，刷卡这个行为，验证的是你的信用卡信息，也就是说只要给刷卡机提供同样的信息，就能从你的账户里把钱刷走。没错，很多朋友都听说过，有犯罪组织专门从事复制卡信息的勾当，然后“盗刷”你的卡。在一些不发达国家的小店里刷卡就特别容易中招。 其次，负责记账和结算的卡组织和银行的服务器可能被黑客攻破，造成数据泄露和伪造交易。回想这些年一波又一波某某大公司数据库被黑客攻入的新闻，这危险并非危言耸听。（好吧，认真的geek会说这里用词应该是cracker骇客而非hacker黑客，不过这年头认真的人越来越少了） 最后，还有一种可能，就是用卡人自己可能利用系统网络延迟，在进行第一笔交易、用完所有额度后，趁系统还没记账把额度扣完，立刻进行第二笔交易，形成诈骗。当然目前的结算系统延迟极小，这情况不太可能，不过像在优惠券或者抢购资格这种另外搭建的相对脆弱的系统上还是有可能的。 网上支付也一样，犯罪分子可以用特殊手段（例如木马，伪造WIFI等）截获你跟服务器之间的传递数据，如果商家加密技术太弱的话信息就可能被破解——嗯，某国很多时候数据干脆是不加密的。所以大家才一直被警告不要乱装程序、不要连可疑的WiFi。 区块链是怎么处理这些问题的呢？我们以比特币交易为例，逐条分析。 首先，比特币拥有者想要完成某项交易，比如买手机吧，他会向全网广播：我小A向小B支付1个比特币（嗯，这金额现在大致可以买个5个iPhone 8）。 与这条信息一起的，还有一条加密信息，这条信息是用Hash函数对上一条信息加密生成一个摘要后，再用A的私钥进行加密的（称为私钥“签名”）。 接收到这条信息的B和其他用户先用同样的Hash函数对明文信息生成摘要，再用A的公钥对加密信息进行解密，如果解密得到的摘要与明文生成的摘要相同，便认为信息确实是A发出的，且没有经过篡改。 A的公钥和Hash是公开的，私钥则无法算出，只有A知道，这样就既保证了交易的达成，又保证了A的信息无法被窃取。 其次，由在POW（运算力证明）中胜出的矿工负责这段时间的记账，事先完全无法知道究竟哪个矿工来记账，黑客也就无从黑起，除非碰运气。 最后，在传统系统中因为结算速度极快而不太可能的情况，在比特币网络中反而可能性比较大。因为没有中心化的管理者，交易确认的时间要长很多，使得这种诈骗有可能实现，这就是比特币的double spending双重花费问题，简称“双花”。 对于双花问题，比特币网络，或者说区块链网络，是这么应对的： -每笔交易都需要先确认对应比特币之前的状态，如果它之前已经被标记为花掉，那么新的交易会被拒绝。 -如果先发起一笔交易，在它被确认前，也就是这个时间段的交易还未被记账成区块block时，进行矛盾的第二笔交易，那么在记账时，这些交易会被拒绝。 -上面只是小伎俩，现在tricky的部分开始了。如果诈骗者刻意把第一笔交易向一半网络进行广播，把第二笔交易向另一半网络广播——这个诈骗者智商还挺高——然后两边正好有两个矿工几乎同时取得记账权，把各自记的block发布给大家的话（这个概率很低），网络是不是会混乱呢，区块链的规则是这样的：先选择任意一个账本都可以，这时候原来统一的账本出现了分叉： 但是在两个账本中各只有一笔交易，诈骗者不会有好处。接下来，下一个矿工选择在A基础上继续记账的话，A分支就会比B分支更长，根据区块链的规则，最长的分支会被认可，短的分支会被放弃，账本还是会回归为一个，交易也只有一笔有效： -那么如果这个诈骗犯真的智商非常高，他会这么做：如果是A分支被认可（B也一样），相应交易确认，拿到商品之后，立刻自己变身矿工，争取到连续两次记账权，然后在B分支上连加两个block，就像这样： 于是B分支成为认可的分支，A被舍弃，A分支中的交易不再成立，但他已经拿到商品，诈骗成功。 在B分支落后的情况下要强行让它超过A分支，其实是挺难的，假设诈骗者掌握了全网1%的计算能力，那么他争取到记账权的概率就是1%，两次就是10的负4次方。但这个概率还没有太低。 应对办法呢？建议大家在一笔交易确认后，也就是一个block被记下来之后，再等5个block，也就是等6个block被确认后再把交易对应的商品交付。这样，诈骗者还能追上的概率就几乎为0了。除非…… 如果诈骗者掌握了全网50%以上的计算力，那么，即使落后很多，他追上也只是时间问题，这就是比特币的“51%攻击”。 这就是区块链需要警惕的问题。虽然在比特币网络中，用户已经极多，全网算力总和非常大，如果真掌握50%以上，也不用靠这个诈骗了，挖矿的收益都更高。但是在小的区块链网络中呢？况且，没有50%以上的算力，还是有机会成功的，只是概率低而已。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>双花问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是区块链]]></title>
    <url>%2F2018%2F09%2F04%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[【定义】区块链（Blockchain）是指通过去中心化和去信任的方式集体维护一个可靠数据库的技术方案。该技术方案让参与系统中的任意多个节点，把一段时间系统内全部信息交流的数据，通过密码学算法计算和记录到一个数据块（block），并且生成该数据块的指纹用于链接（chain）下个数据块和校验，系统所有参与节点来共同认定记录是否为真。 区块链是一种类似于NoSQL（非关系型数据库）这样的技术解决方案统称，并不是某种特定技术，能够通过很多编程语言和架构来实现区块链技术。并且实现区块链的方式种类也有很多，目前常见的包括POW（Proof of Work，工作量证明），POS（Proof of Stake，权益证明），DPOS（Delegate Proof of Stake，股份授权证明机制）等。 区块链的概念首次在论文《比特币：一种点对点的电子现金系统（Bitcoin: A Peer-to-Peer Electronic Cash System）》中提出，作者为自称中本聪（Satoshi Nakamoto）的个人（或团体）。因此可以把比特币看成区块链的首个在金融支付领域中的应用。 【通俗解释】无论多大的系统或者多小的网站，一般在它背后都有数据库。那么这个数据库由谁来维护？在一般情况下，谁负责运营这个网络或者系统，那么就由谁来进行维护。如果是微信数据库肯定是腾讯团队维护，淘宝的数据库就是阿里的团队在维护。大家一定认为这种方式是天经地义的，但是区块链技术却不是这样。 如果我们把数据库想象成是一个账本：比如支付宝就是很典型的账本，任何数据的改变就是记账型的。数据库的维护我们可以认为是很简单的记账方式。在区块链的世界也是这样，区块链系统中的每一个人都有机会参与记账。系统会在一段时间内，可能选择十秒钟内，也可能十分钟，选出这段时间记账最快最好的人，由这个人来记账，他会把这段时间数据库的变化和账本的变化记在一个区块（block）中，我们可以把这个区块想象成一页纸上，系统在确认记录正确后，会把过去账本的数据指纹链接（chain）这张纸上，然后把这张纸发给整个系统里面其他的所有人。然后周而复始，系统会寻找下一个记账又快又好的人，而系统中的其他所有人都会获得整个账本的副本。这也就意味着这个系统每一个人都有一模一样的账本，这种技术，我们就称之为区块链技术（Blockchain），也称为分布式账本技术。 由于每个人（计算机）都有一模一样的账本，并且每个人（计算机）都有着完全相等的权利，因此不会由于单个人（计算机）失去联系或宕机，而导致整个系统崩溃。既然有一模一样的账本，就意味着所有的数据都是公开透明的，每一个人可以看到每一个账户上到底有什么数字变化。它非常有趣的特性就是，其中的数据无法篡改。因为系统会自动比较，会认为相同数量最多的账本是真的账本，少部分和别人数量不一样的账本是虚假的账本。在这种情况下，任何人篡改自己的账本是没有任何意义的，因为除非你能够篡改整个系统里面大部分节点。如果整个系统节点只有五个、十个节点也许还容易做到，但是如果有上万个甚至上十万个，并且还分布在互联网上的任何角落，除非某个人能控制世界上大多数的电脑，否则不太可能篡改这样大型的区块链。 【要素】结合区块链的定义，我们认为必须具有如下四点要素才能被称为公开区块链技术，如果只具有前3点要素，我们将认为其为私有区块链技术（私有链）。 1、点对点的对等网络（权力对等、物理点对点连接） 2、可验证的数据结构（可验证的PKC体系，不可篡改数据库） 3、分布式的共识机制（解决拜占庭将军问题，解决双重支付） 4、纳什均衡的博弈设计（合作是演化稳定的策略） 【特性】结合定义区块链的定义，区块链会现实出四个主要的特性：去中心化（Decentralized）、去信任（Trustless）、集体维护（Collectively maintain）、可靠数据库（Reliable Database）。并且由四个特征会引申出另外2个特征：开源（Open Source）、隐私保护（Anonymity）。如果一个系统不具备这些特征，将不能视其为基于区块链技术的应用。 去中心化（Decentralized）：整个网络没有中心化的硬件或者管理机构，任意节点之间的权利和义务都是均等的，且任一节点的损坏或者失去都会不影响整个系统的运作。因此也可以认为区块链系统具有极好的健壮性。 去信任（Trustless）：参与整个系统中的每个节点之间进行数据交换是无需互相信任的，整个系统的运作规则是公开透明的，所有的数据内容也是公开的，因此在系统指定的规则范围和时间范围内，节点之间是不能也无法欺骗其它节点。 集体维护（Collectively maintain）：系统中的数据块由整个系统中所有具有维护功能的节点来共同维护的，而这些具有维护功能的节点是任何人都可以参与的。 可靠数据库（Reliable Database）：整个系统将通过分数据库的形式，让每个参与节点都能获得一份完整数据库的拷贝。除非能够同时控制整个系统中超过51%的节点，否则单个节点上对数据库的修改是无效的，也无法影响其他节点上的数据内容。因此参与系统中的节点越多和计算能力越强，该系统中的数据安全性越高。 开源（Open Source）：由于整个系统的运作规则必须是公开透明的，所以对于程序而言，整个系统必定会是开源的。 隐私保护（Anonymity）：由于节点和节点之间是无需互相信任的，因此节点和节点之间无需公开身份，在系统中的每个参与的节点的隐私都是受到保护。 【区块链意义之一 ：解决拜占庭将军问题】区块链解决的核心问题不是“数字货币”，而是在信息不对称、不确定的环境下，如何建立满足经济活动赖以发生、发展的“信任”生态体系。而这个问题称之为“拜占庭将军问题”，也可称为“拜占庭容错”或者“两军问题”，这是一个分布式系统中进行信息机交互时面临的难题，即在整个网络中的任意节点都无法信任与之通信的对方时，如何能创建出共识基础来进行安全的信息交互而无需担心数据被篡改。区块链使用算法证明机制来保证整个网络的安全，借助它，整个系统中的所有节点能够在去信任的环境下自动安全的交换数据。更多介绍请参见《比特币与拜占庭将军问题》。 【区块链意义之二：实现跨国价值转移】互联网诞生最初，最早核心解决的问题是信息制造和传输，我们可以通过互联网将信息快速生成并且复制到全世界每一个有着网络的角落，但是它尚始终不能解决价值转移和信用转移。这里所谓的价值转移是指，在网络中每个人都能够认可和确认的方式，将某一部分价值精确的从某一个地址转移到另一个地址，而且必须确保当价值转移后，原来的地址减少了被转移的部分，而新的地址增加了所转移的价值。这里说的价值可以是货币资产，也可以是某种实体资产或者虚拟资产（包括有价证券、金融衍生品等）。而这操作的结果必须获得所有参与方的认可，且其结果不能受到任何某一方的操纵。 在目前的互联网中也有各种各样的金融体系，也有许多政府银行提供或者第三方提供的支付系统，但是它还是依靠中心化的方案来解决。所谓中心化的方案，就是通过某个公司或者政府信用作为背书，将所有的价值转移计算放在一个中心服务器（集群）中，尽管所有的计算也是由程序自动完成，但是却必须信任这个中心化的人或者机构。事实上通过中心化的信用背书来解决，也只能将信用局限在一定的机构、地区或者国家的范围之内。由此可以看出，必须要解决的这个根本问题，那就是信用。所以价值转移的核心问题是跨国信用共识。 在如此纷繁复杂的全球体系中，要凭空建立一个全球性的信用共识体系是很难的，由于每个国家的政治、经济和文化情况不同，对于两个国家的企业和政府完全互信是几乎做不到的，这也就意味着无论是以个人抑或企业政府的信用进行背书，对于跨国之间的价值交换即使可以完成，也有着巨大的时间和经济成本。但是在漫长的人类历史中，无论每个国家的宗教、政治和文化是如何的不同，唯一能取得共识的是数学（基础科学）。因此，可以毫不夸张的说，数学（算法）是全球文明的最大公约数，也是全球人类获得最多共识的基础。如果我们以数学算法（程序）作为背书，所有的规则都建立一个公开透明的数学算法（程序）之上，能够让所有不同政治文化背景的人群获得共识。 【未来的发展】互联网将使得全球之间的互动越来越紧密，伴随而来的就是巨大的信任鸿沟。目前现有的主流数据库技术架构都是私密且中心化的，在这个架构上是永远无法解决价值转移和互信问题。所以区块链技术有可能将成为下一代数据库架构。通过去中心化技术，将能够在大数据的基础上完成数学（算法）背书、全球互信这个巨大的进步。 区块链技术作为一种特定分布式存取数据技术，它通过网络中多个参与计算的节点开共同参与数据的计算和记录，并且互相验证其信息的有效性（防伪）。从这一点来，区块链技术也是一种特定的数据库技术。互联网刚刚进入大数据时代，但是从目前来看，大数据还处于非常基础的阶段。但是当进入到区块链数据库阶段，将进入到真正的强信任背书的大数据时代。这里面的所有数据都获得坚不可摧的质量，任何人都没有能力也没有必要去质疑。 也许我们现在正处在一个重大的转折点之上——和工业革命所带来的深刻变革几乎相同的重大转折的早期阶段。不仅仅是新技术指数级、数字化和组合式的进步与变革，更多的惊喜也许还会在我们前面。在未来的24个月里，这个星球所增长的计算机算力和记录的数据将会超过所有历史阶段的总和。在过去的24个月里，这个增值可能已经超过了1000倍。这些数字化的数据信息还在以比摩尔定律更快的速度增长。区块链技术将不仅仅应用在金融支付领域，而是将会扩展到目前所有应用范围，诸如去中心化的微博、微信、搜索、租房，甚至是打车软件都有可能会出现。因为区块链将可以让人类无地域限制的、去信任的方式来进行大规模协作。 我们这一代人将很可能会幸运地经历人类历史上两个最让人吃惊的事件，地球上的所有人和所有机器通过区块链技术以前所未有的互信展开了空前的大规模协作，其次就是基于此真正的人工智能将被创造出来。这两个时间将会深深地改变这个世界的经济发展模式。创业者、企业家、科学家以及各种各样的极客将利用这个充裕的世界去创造能让我们震惊和快乐。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜占庭将军问题]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[拜占庭将军问题（Byzantine failures）是由莱斯利·兰伯特提出的点对点通信中的基本问题。含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。因此对一致性的研究一般假设信道是可靠的，或不存在本问题。这个难题也被称为“拜占庭容错”、“拜占庭将军问题”、或者“两军问题”。 拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。 拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。 首先，不要把比特币当成一种货币，而是一个总账。它是个电子账本，网络上的每一个参与者的电脑都会有一份账本的备份，并且所有的备份都是在实时的持续的更新、对账、以及同步着。每一个参与者都能在这本账本里记上一笔，这一笔记录着一定数量的币从一个参与者那里被发送到另一个参与者那里，并且每一条这样的记录都接着就实时的广播到网络了，所以在每一台电脑上的每一分份拷贝都是几乎同时更新的，并且所有的账本拷贝都保持着同步。这本公开的分布式的账本就可以称为“区块链（blockchain）”，并且它使用了BT技术以保证所有的拷贝都是同步的。 可以把比特币当作一个对于在分布式系统领域的一个复杂的算法难题的通用解决方法。 这一问题的趣味非正式表述如下：想象一下，在拜占庭时代有一个墙高壁厚的城邦，拜占庭，高墙之内是它的邻居想象不到之多的财富。它被其他10个城邦所环绕，这10个城邦也很富饶，但和拜占庭相比就微不足道了。它的十个邻居都觊觎拜占庭的财富，并希望侵略并占领它。 但是，拜占庭的防御是如此的强大，没有一个相邻的城邦能够成功入侵。任何单个城邦的入侵行动都会失败，而入侵者的军队也会被歼灭，使得其自身容易遭到其他九个城邦的入侵和劫掠。这十个城邦之间也互相觊觎对方的财富并持续互相对抗着。而且，拜占庭的防御如此之强，十个邻居的一半以上同时进攻才能攻破它。 也就是说，如果六个或者更多的相邻敌军一起进攻，他们就会成功并获得拜占庭的财富。然而，如果其中有一个或者更多背叛了其他人，答应一起入侵但在其他人进攻的时候又不干了，也就导致只有五支或者更少的军队在同时进攻，那么所有的进攻军队都会被歼灭，并随后被其他的（包括背叛他们的那（几）个）邻居所劫掠。这是一个由不互相信任的各方构成的网络，但他们又必须一起努力以完成共同的使命。 而且，是个邻居之间通讯和协调统计时间的唯一途径是通过骑马在他们之间传递信息。他们不能聚在一个地方开个会（所有的王都不互相信任他们的安全在自己的城堡或者军队范围之外能够得到保障）。然而，他们可以在任意时间以任意频率派出任意数量的信使到任意的对方。每条信息都包含类似如下的内容：“我将在第四天的6点钟进攻，你愿意加入吗？”。 如果收信人同意了，他们就会在原信上附上一份签名了的/认证了的/盖了图章的/验证了的回应，然后把新合并了的信息的拷贝再次发送给九个邻居，要求他们也如此这样做。最后的目标是，通过在原始信息链上盖上他们所有十个人的图章，让他们在时间上达成共识。最后的结果是，会有一个盖有十个同意同一时间的图章信息链，可能还会有一些被抛弃了的包含部分但不是全部图章的信息链。 但是，问题在于如果每个城邦向其他九个城邦派出一名信使，那么就是十个城邦每个派出了九名信使，也就是在任何一个时间又总计90次的传输，并且每个城市分别收到九个信息，可能每一封都写着不同的进攻时间。除此以外，部分城邦会答应超过一个的攻击时间，故意背叛发起人，所以他们将重新广播超过一条的信息链。这个系统迅速变质成不可信的信息和攻击时间相互矛盾的纠结体。 比特币通过对这个系统做出一个简单的（事后看是简单的）修改解决了这个问题，它为发送信息加入了成本，这降低了信息传递的速率，并加入了一个随机元素以保证在一个时间只有一个城邦可以进行广播。它加入的成本是“工作量证明”，并且它是基于计算一个随机哈希算法的。哈希是一种算法，它唯一做的事情就是获得一些输入然后进行计算，并得到一串64位的随机数字和字母的字符串，就像这个： 1d70298566aa2f1a66d892dc31fedce6147b5bf509e28d29627078d9a01a8f86b 在比特币的世界中，输入数据包括了到当前时间点的整个总账（区块链）。并且尽管单个哈希值用现在的计算机可以几乎即时的计算出来，但只有一个前13个字符是0的哈希值结果可以被比特币系统接受成为“工作量证明”。这样一个13个0的哈希值是极其不可能与罕见的，并且在当前需要花费整个比特币网络大约10分钟的时间来找到一个。在一台网络中的机器随机的找到一个有效哈希值之前，上十亿个的无效值会被计算出来，这就是减慢信息传递速率并使得整个系统可用的“工作量证明”。下面是一个例子： 123f51d0199c4a6d9f6da230b579d850698dff6f695b47d868cc1165c0ce74df5e1d70298566aa2f1a66d892dc31fedce6147b5bf509e28d29627078d9a01a8f86b119c506ceaa18a973a5dbcfbf23253bc970114edd1063bd1288fbba468dcb7f8 在找到一个有效值之前，成百万上亿个更多的类似上面这样的字符串被计算出来…… 1000000000000084b6550604bf21ad8a955b945a0f78c3408c5002af3cdcc14f5 那台发现下一个有效哈希值的机器（或者说在我们类比中的城邦），把所有的之前的信息放到一起，附上它自己的，以及它的签名/印章/诸如此类，并向网络中的其他机器广播出去。只要其他网络中的机器接收到并验证通过了这个13个0的哈希值和附着在上面的信息，他们就会停止他们当下的计算，使用新的信息更新他们的总账拷贝，然后把新更新的总账/区块链作为哈希算法的输入，再次开始计算哈希值。哈希计算竞赛从一个新的开始点重新开始。如此这般，网络持续同步着，所有网络上的电脑都使用着同一版本的总账。 与此同时，每一次成功找到有效哈希值以及区块链更新的间隔大概是10分钟（这是故意的，算法难度每两周调整一次以保证网络一直需要花费10分钟来找到一个有效的哈希值）。在那10分钟以内，网络上的参与者发送信息并完成交易，并且因为网络上的每一条机器都是使用同一个总账，所有的这些交易和信息都会进入遍布全网的每一份总账拷贝。当区块链更新并在全网同步之后，所有的在之前的10分钟内进入区块链的交易也被更新并同步了。因此分散的交易记录是在所有的参与者之间进行对账和同步的。 最后，在个人向网络输入一笔交易的时候，他们使用内嵌在比特币客户端的标准公钥加密工具来同时他们的私钥以及接收者的公钥来为这笔交易签名。这对应于拜占庭将军问题中他们用来签名和验证消息时使用的“印章”。因此，哈希计算速率的限制，加上公钥加密，使得一个不可信网络变成了一个可信的网络，使得所有参与者可以在某些事情上达成一致（比如说攻击时间、或者一系列的交易、域名记录、政治投票系统、或者任何其他的需要分布式协议的地方）。 这里是比特币为何如此特别的关键：它代表了一个对于一个困难的算法上的难题的解决方案，这一解决方案在一系列的历史事件发生之前是不可能的，这些事件有： 互联网的创造 公钥加密算法的发明 点对点Bitorrent(BT)协议的发明。BT协议最开始是开发来用于在网络上的相对小的用户子集之间共享许多文件的，但比特币用它来在所有用户之间共享单个文件。 人们意识到，在系统中添加一个简单的时间延迟，同时使用公钥加密算法以验证每笔交易，可以解决这个问题。 如果说一些最棒的想法在事后看来是很简单的，那么上述的第四点就完全符合条件，尽管整个项目是站在了巨人的肩膀上的。 最后，这一对于拜占庭将军问题的解决方案，可以推广到任何核心问题是在分布式网络上缺乏信任的领域。如我们已经提到乐的，人们正在为互联网建设一个分布式的域名系统，以及为政治选举建设分布式的投票系统（还没有网站）。如果人们认为单纯的文件分享搅乱了这个世界，那么比特币解决方案和协议才刚刚打开洪水的闸门。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>拜占庭将军问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的链式存储结构]]></title>
    <url>%2F2018%2F09%2F04%2F%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。 为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。链队列示意图： 当队列为空时，front和rear都指向头结点 实例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( "errors" "fmt")type qelemType int//数据节点(链表形式)type QNode struct &#123; data qelemType next *QNode&#125;type queuePtr *QNode//定义队列type LinkQueue struct &#123; front, rear queuePtr&#125;//创建头结点func createHeadNode(q *LinkQueue) &#123; s := queuePtr(new(QNode)) s.next = nil q.front = s q.rear = s&#125;//如队列操作func enQueue(q *LinkQueue, e qelemType) &#123; s := queuePtr(new(QNode)) s.data = e s.next = nil //队尾为空 q.rear.next = s q.rear = s //rear指向新添加的数据（保证指向最后一个元素）&#125;//出队列func deQueue(q *LinkQueue) (err error, res qelemType) &#123; if q.front == q.rear &#123; err = errors.New("队列为空，没有数据出队列") return &#125; s := q.front.next res = s.data q.front.next = s.next if q.rear == s &#123; q.rear = q.front &#125; return&#125;func main() &#123; var p LinkQueue /* 注意 需要创建头结点，不然头结点为空，操作它的.next 会发生异常,异常信息如下： panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x0 addr=0x0 pc=0x48b5c9] */ createHeadNode(&amp;p) enQueue(&amp;p, qelemType(123)) enQueue(&amp;p, qelemType(345)) enQueue(&amp;p, qelemType(567)) _, res := deQueue(&amp;p) fmt.Println(res) _, res = deQueue(&amp;p) fmt.Println(res) _, res = deQueue(&amp;p) fmt.Println(res) err, res := deQueue(&amp;p) fmt.Println(err, res)&#125; 运行效果：]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言之陷阱for range]]></title>
    <url>%2F2018%2F09%2F04%2Fgo%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%99%B7%E9%98%B1for-range%2F</url>
    <content type="text"><![CDATA[在go语言中，遍历有两种方法，一种就是for的普通方法，还有一种就是for range的遍历，但是在使用for range时，如果使用不当，就会出现一些问题比如我们下面先来看一个例题 123456789101112131415161718192021package mainimport "fmt"type Student struct&#123; Name string Age int&#125; //一个学生结构体func main()&#123; m:=make(map[string]*Student) //声明一个映射 stus:=[]Student&#123; &#123;"宋",22&#125;, &#123;"高",23&#125;, &#123;"徐",24&#125;, &#123;"李",25&#125;, &#125; //一个学生类切片 for _,stu:=range stus&#123; m[stu.Name]=&amp;stu //遍历赋值给映射 &#125; for _,value:=range m&#123; fmt.Println(*value) //遍历打印出来 &#125;&#125; 我们的代码是把stus这个结构体切片里面的内容用for range赋值给m映射，看起来代码好像没什么问题，一次循环赋值一次循环打印，那我们来看一下打印结果是什么 打印结果竟然是这样，为什么都是一样的呢，而且是结构体切片最后的一个元素，看下面这张图 这是因为我们第一次使用for range遍历的时候 我们是使用零时变量stu的地址来传给m的，而且零时变量stu每次的地址都是不会变的，所以一直到遍历最后一次就会把最后一个值的地址传给m，这就导致了m里面的值都是一样，我们可以试着来打印一下地址来看看 我们先来打印一下m看看 看到没，这四个地址竟然都是一样的，这就是因为用stu零时变量去地址去传的话地址都是一样的，那样传值就达不到预期的效果，所以一定要小心这个陷阱，那我们上面应该怎样改就可以完整的传值呢 看到没，我们可以在for range里面弄一个stu1来接受零时变量stu的值，然后取stu1的地址传值，这样就不会出错啦，我们来看看打印结果 这样我们每次的地址也不一样了，打印出来的结果也就正确达到预期的结果了，因为map是无序的所以打印出来也是无序的，切忌用for range的时候小心陷阱]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言错误捕获和panic异常]]></title>
    <url>%2F2018%2F09%2F04%2Fgo%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7%E5%92%8Cpanic%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[在Go语言中我们首先来看一下err错误信息，我们先来看一段代码 123456789101112131415161718192021222324252627package mainimport ( "fmt" "errors")func calc(a int, b int) (v int, err error) &#123; //捕获错误信息 if b == 0 &#123; //如果代码中出现错误 可以使用errors.New()创建错误信息 err = errors.New("除数不能为0") return &#125; v = a / b return&#125;func main() &#123; a := 10 b := 0 v, err := calc(a, b) //根据错误信息进行处理 if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(v) &#125; //fmt.Println(v)&#125; 在这里我们可以接收到错误信息并打印出来，我们先看一下会报错吗？结果显示部会报错的，因为我们接收到了错误并打印出来了 我们看这里并没有报错，而是打印出了错误 信息， 在Go中我们还可以直接调用panic函数来终止程序， 我们来看这张图，这张图里面我们给数组定义为10个长度，然后下面直接调用下标为10的数组，这样会出什么错误呢，这样就是数组下标超出范围，因为数组下标是从0开始到长度减一，我们来看一下编译器运行的结果报什么错， 编译提示panic异常，然后提示数组下标越界，这是因为当我们写程序时，比如遇到一些错误比如：数组下标越界，空指针异常，野指针这些错误的时候，系统就会调用自己本身的panic函数，那么我们自己在写程序的时候也是可以调用panic函数的，下面来看这段代码 12345678910111213package mainimport "fmt"func main() &#123; fmt.Println("hello world1") fmt.Println("hello world2") fmt.Println("hello world3") //程序可以运行 但是遇到panic停止 //当程序遇到panic时 会自动崩溃 panic("终止程序") fmt.Println("hello world4") fmt.Println("hello world5") fmt.Println("hello world6")&#125; 我们来看一下运行结果 在这里我们看到，只打印了上面的三句话，当遇到panic函数的时候就会程序崩溃，然后下面的程序停止执行，我们不仅仅可以使用panic来终止程序，我们还可以捕获错误后继续执行程序，我们来看下一段代码 12345678910111213141516171819202122package mainimport "fmt"func test(i int) &#123; var arr [10]int //优先使用错误拦截 在错误出现之前进行拦截 在错误出现后进行错误捕获 //错误拦截必须配合defer使用 通过匿名函数使用 defer func() &#123; //恢复程序的控制权 err := recover() if err != nil &#123; fmt.Println(err) &#125; &#125;() arr[i] = 123 //err panic fmt.Println(arr)&#125;func main() &#123; i := 10 test(i) fmt.Println("hello world")&#125; 看这段代码，然后我们来看一下运行结果 第一句话直接打印出了错误：运行时错误，数组下标越界，但是程序并没有终止而是继续运行下去了这是为什么了， 如图所示，这里我们延迟调用了一下，因为recover必须和defer配合使用，并且调用一定要在错误出现之前调用才有效果，这样捕获到了错误并且恢复了程序的控制权。]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>错误捕获</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言切片深入讲解]]></title>
    <url>%2F2018%2F09%2F03%2Fgo%E8%AF%AD%E8%A8%80%E5%88%87%E7%89%87%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们在上一篇的切片讲解中，我们讲解到在go语言中 map和切片都是传引用（地址），也就是在调用函数的时候都是可以直接修改变量的值，关于切片，在某种程度上表面上来说也是可以这样说的，我们先来看一下一个小小的例题 1234567891011package mainimport &quot;fmt&quot;func Change(s []int)&#123; s[0]=11 s[1]=22&#125;func main()&#123; slice:=[]int&#123;1,2,3,4,5&#125; Change(slice) fmt.Println(slice)&#125; 我们先来看一下结果 我们可以看到切片当作函数参数的时候调用之后值确实改变了，这也间接的可以认为切片是地址传递，但是我们想要了解的更深入的话可以继续了解下去 我们继续来看一个小例子 123456789101112package mainimport "fmt"func Add(s []int)&#123; s=append(s,6,7,8)&#125;func main()&#123; slice:=[]int&#123;1,2,3,4,5&#125; Add(slice) fmt.Println(slice)&#125; 在这里函数调用了append这个函数来增加切片的个数， 我们可以清晰的看到打印的结果并没有变，我们在之前讲到过这里是因为append扩容使得地址发生了变化，所以不是指向原来的切片也就导致了并不是在原来的切片上面增加了，这就说到了切片的本质，在这里详细说一下，切片的本质不是指向数组的指针，而是一种新定义的一种数据结构，这个数据结构里面包含一个指针，len，还有cap， 12345type slice struct &#123; *Pointer len cap &#125; 看到没，切片的本质是这样一个数据结构，而且在函数调用的时候切片做的其实是一个值的传递！！！只不过这个值是一个包含指针，长度，容量的一个结构体的值，这样我们一想就可以一目了然的知道了为什么前面我们所说的切片是地址传递了吧，那是因为他传的那个值里面包含一个指针，所以函数调用的时候就可以用这个值里面的指针来操作原来的切片，我们看如下的一张图片， 我们看上面的图就可以更加的明白了，在函数调用的时候首先，在栈区里面main函数会得到一块内存（栈帧），然后调用testFunc函数的时候testFunc也会得到一块内存（栈帧），然后调用的时候把切片的值传递给形参，注意这里的值是包含一个指针，长度，容量的结构体值，我们在使用一般操作的时候不会改变那个地址，所以会正常操作main函数里面的切片，当我们使用append函数的时候就会导致保存的指针值发生变化，那样就会保存一个新的地址，操作也会在新的地方操作，这样的话原来的切片就不会发生变化，当testFunc函数调用完毕后，我们的testFunc函数就会释放，而原来的切片也没有得到改变，这就是我们所看到的，这才是切片的本质 所以最后得到的总结就是：切片当作参数传递的时候是值传递，但是这个值不是一个普通的值，而是一个包含指针，长度，容量的值，如果有不懂的也可以尝试着去看一看源码。 附图：（内存的微讲解）]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言切片微讲解]]></title>
    <url>%2F2018%2F09%2F03%2Fgo%E8%AF%AD%E8%A8%80%E5%88%87%E7%89%87%E5%BE%AE%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[传递参数时分为值传递和地址传递，go语言中切片和map是地址传递，但是切片传递要有一个注意事项 例如： 123456789package mainfunc test(a []int)&#123; a=append(a,1,2,3)&#125;func main()&#123; var s []int=[]int&#123;89,4,5,6&#125; test(s) fmt.Println(s)&#125; 在这里里面为什么调用函数后切片没有变化呢，切片不是地址传递吗？这是因为在test函数里面用了append()函数,在调用函数时，在栈区里面把1 2 3 添加到a里面然后重新分配了地址，而原来的s切片还是指向原来地址，根本没有变，所以在main函数里面打印出s还是原来的，不会改变，那么如何做到用了append后改变原来切片的值呢 如下 1234567891011package mainimport "fmt"func test(a []int)(b []int)&#123; b=append(a,1,2,3,7) return&#125;func main()&#123; var s []int=[]int&#123;9,10&#125; s=test(s) fmt.Println(s)&#125; 我们可以用return 把改变后的地址传回去这样就可以了 切片用append函数的时候一定要注意，因为如果容量不足的时候会自动扩充，如果原来的地址后面没有足够的空间那么就会重新找一个足够大的空间来储存，所以切片利用append的时候地址是有可能变化的。]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序在上一章中我们讲了算法排序中的最简单的冒泡排序，今天我们来讲解一下插入排序，后续将讲解快速排序，归并排序，希尔排序，二叉排序，这些等等，后续的排序都是在时间复杂度和空间复杂度上面优于这两种的，所以我们今天先来讲解一下插入排序 我们先来看以下的一张图 为了方便排序，我们一般将数据的第一个元素作为有序组，其他视为待插入组，图中以升序为例子进行讲解。 我们将第一个元素作为有序的数组，然后将后面的元素视为无序的，将后面的无序组第一个元素和有序组最后一个元素比较，如果符合要求就插入进去然后有序组就多一个，无序组就少一个 第二次排序的时候有序组就为两个元素，有序组的最后一个元素拿出来继续和无序组的第一个相比，然后再插入一个，这样有序组就又多了一个，无序组少一个 这样一直循环到某个条件，这样无序组就没有了，剩下的都是有序组，这样排序就完成了。 我们来看一下代码怎样实现，在这里我们就用GO语言来实现，在某些方面个人觉得go写的代码比C/C++要少很多，更加方便一点 12345678910111213141516package mainimport "fmt"func main() &#123; var arr [10]int = [10]int&#123;9, 1, 3, 4, 7, 5, 2, 10, 11, 8&#125; //插入排序 var temp ,j int //临时变量temp for i := 1; i &lt; len(arr); i++ &#123; //遍历无序数组,下标1开始 if arr[i] &lt; arr[i-1] &#123; //无序组第一个小于有序组最后一个才进入否则直接下一个元素 temp=arr[i] //用变量temp取出arr[i]的元素值 for j=i-1;j&gt;=0&amp;&amp;arr[j]&gt;temp;j--&#123; //这里面temp不能写成arr[i]是因为下面 arr[j+1]=arr[j] // 有一个arr[j+1]=arr[j]那样会导致arr[i]会变 &#125; arr[j+1]=temp //因为上面经过了j--所以这里需要arr[j+1]，for循环后就找到位置填充temp，也就是之前取出来的arr[i] &#125; &#125; fmt.Println(arr)&#125; 下面你可以自己去实现一下了，后续将讲解更难的排序方法。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>排序问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程算法题]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天的题目为： 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 无重复字符的最长子串是 "wke"，其长度为 3。 请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。 首先来思路分析：我们可以先第一次把所有不重复的字符串分割一下保存下来，这样就可以找到这一次的不重复的子字符串最长的 然后在一次一次往后面移动，这样就可以找出所有不重复的子字符串，最后再求出最大值。 比如： abcd ahjiklo字符串 我们第一次从头开始寻找，找到不重复的子字符串，那就有两个，一个为abcd另外一个为ahjiklo,如果单单重上面看那么最长的不重复子字符串就是ahjiklo，但是我们需要的不是这个，那么我们就需要再循环一次，每次把第一个字符去掉然后再寻找，比如这一次把a去掉那么找出的最长子字符串就是bcdahjiklo，这个是最长的，然后再把本次的第一个字符去掉一直循环，这样到最后找出最长的子字符串， 复杂度分析：当然，这种方法可以算是一种暴力解决的方法，没有什么技巧性，时间复杂度也是最复杂的，O（n3）的复杂度，当然如果想要优化的话可以自己去研究一下奥。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport "fmt"func lengthOfLongestSubstring(str string) int &#123; //每次求出的最大值返回 s:=[]byte(str) //先把字符串转为byte类型的切片 slice:=make([]string,0)//ased//aerfch//risdud //定义一个字符串切片，可以把无重复的字符串字段保存进去flag: for i:=0;i&lt;len(s);i++&#123; for j:=i-1;j&gt;=0;j--&#123; if s[i]==s[j]&#123; //这里遍历用来找出无重复字符串段 slice=append(slice,string(s[:i])) //把无重复字符段放切片里面去 s=s[i:] //切片往后移 goto flag; //在新切片里面再次循环直到找出无重复字符段放进字符串切片里面 &#125; &#125; &#125; slice=append(slice,string(s)) //把最后一个放进切片，如果整个字符串都没有重复那么就这一个 //fmt.Println(slice) max:=len(slice[0]) for k:=0;k&lt;len(slice);k++&#123; //循环找出这一次的最大值 if len(slice[k])&gt;max&#123; max=len(slice[k]) &#125; &#125; return max //返回本次最大值&#125;func main()&#123; var str string fmt.Printf("请输入一个字符串\n") fmt.Scanf("%s",&amp;str) var max int for i:=len(str);i&gt;0;i--&#123; tmp:=lengthOfLongestSubstring(str) //每求一次最大值往后退一次，确保能得到真正的最大值 if tmp&gt;max&#123; max=tmp &#125; str=str[1:] //每次用切片割掉第一个元素 &#125; fmt.Println(max) //输出最大值，这里也可以输出最长的子字符串&#125; 这样就可以求出来了，如果想要优化的伙伴可以自己去稍加研究。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一条简单区块链的实现]]></title>
    <url>%2F2018%2F09%2F02%2F%E4%B8%80%E6%9D%A1%E7%AE%80%E5%8D%95%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在上一章中我们讲解了一个简单的区块创建，那么我们今天来讲解一下一条简单区块链的实现 思路分析： 创建一个创世块，就是区块链的头 //上一章节中讲解了如果实现一个区块的简单实现 定义一个结构体，用来保存区块链中的区块，结构体里面的元素可以就是那条链 用方法来实现区块的添加，每次调用方法都加进相应的区块 第一步实现 1234567type Block struct &#123; //创建一个区块的结构体 Time int64 //时间戳 Data []byte //数据信息 PreviousHash []byte //前一个哈希值 Hash []byte //当前的哈希&#125; 第二步实现 123type Blockchain struct&#123; //创建一个区块链类型 blocks []*Block //一系列区块储存，这里用切片来保存&#125; 第三步实现 123456789101112func (blockchain *Blockchain)Addblock(data string)&#123; //添加区块的方法 newblock:=Block&#123;&#125; //一个新区块 newblock.Data=[]byte(data) //初始化数据 newblock.PreviousHash=blockchain.blocks[len(blockchain.blocks)-1].Hash //得到前一个区块的哈希 newblock.Sethash() //得到哈希 blockchain.blocks=append(blockchain.blocks,&amp;newblock) //新区块添加到这条链当中&#125;func Newblockchain()*Blockchain&#123; // 创建一条新的区块链 blos:=Blockchain&#123;[]*Block&#123;Firstblock()&#125;&#125; //初始化 return &amp;blos&#125; 这样新的区块链就完成的差不多了，加上上一章的简单实现区块链的代码就已经实现了，下面我们整理一下将得到如下的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( "time" "strconv" "bytes" "crypto/sha256" "fmt")/*一个简单的区块链创建*/type Block struct &#123; //创建一个区块的结构体 Time int64 //时间戳 Data []byte //数据信息 PreviousHash []byte //前一个哈希值 Hash []byte //当前的哈希&#125;type Blockchain struct&#123; //创建一个区块链类型 blocks []*Block //一系列区块储存，这里用切片来保存&#125;func (blockchain *Blockchain)Addblock(data string)&#123; //添加区块的方法 newblock:=Block&#123;&#125; //一个新区块 newblock.Data=[]byte(data) //初始化数据 newblock.PreviousHash=blockchain.blocks[len(blockchain.blocks)-1].Hash //得到前一个区块的哈希 newblock.Sethash() //得到哈希 blockchain.blocks=append(blockchain.blocks,&amp;newblock) //新区块添加到这条链当中&#125;func Newblockchain()*Blockchain&#123; // 创建一条新的区块链 blos:=Blockchain&#123;[]*Block&#123;Firstblock()&#125;&#125; //初始化 return &amp;blos&#125;func Firstblock()*Block&#123; firstblock:=Newblock("firstblock",[]byte&#123;&#125;) return firstblock&#125;func (block *Block)Sethash()&#123; timer:=[]byte(strconv.FormatInt(block.Time,10)) herds:=bytes.Join([][]byte&#123;timer,[]byte(block.Data),block.PreviousHash&#125;,[]byte&#123;&#125;) hash:=sha256.Sum256(herds) block.Hash=hash[:]&#125;func Newblock(data string,prevhash []byte)*Block&#123; block:=Block&#123;&#125; block.Time=time.Now().Unix() block.Data=[]byte(data) block.PreviousHash=prevhash block.Sethash() return &amp;block&#125;func main() &#123; //创建一个区块链 blocks:=Newblockchain() blocks.Addblock("seng one BTC to sary") //信息（数据）为seng one BTC to sary 添加到区块链中 blocks.Addblock("send two ETH to wuman")//信息（数据）为send two ETH to wuman 添加到区块链中 blocks.Addblock("send one ADA to zijian")//信息（数据）为send one ADA to zijian 添加到区块链中 for _,v:=range blocks.blocks&#123; //循环遍历打印一下看结果 fmt.Println("=======================================") fmt.Printf("data=:%s\n",v.Data) fmt.Printf("prevhash:=%x\n",v.PreviousHash) fmt.Printf("hash:=%x\n",v.Hash) &#125;&#125; 我们来看一下结果：]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单区块的实现]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B01%2F</url>
    <content type="text"><![CDATA[简单区块实现区块链技术如今已经越来越成熟，但是我们怎么深入到本质用技术的眼光来看待区块链技术，见名知意，区块链的意思就是用链条把区块链接起来，那我们先用代码来看一下，今天我们用go语言来简单的实现一个区块并打印。 我们可以先来理一下思路，我们想要实现一个区块该怎么办，思路理好然后再来代码一步一步实现 创建一个结构体来保存一个区块的信息 //大概包括时间戳，数据，前哈希，本哈希这几个数据 创建第一个区块并给其中的数据赋值，也就相当于一个创世块，注意这里创世块的前哈希传一个空值就可以 给这个区块的数据处理一下然后加密得到本区块的哈希 主函数里面打印看一下本区块的哈希 //哈希用16进制打印 大概这样思路就可以理顺了，然后我们就可以一步一步实现了 1：第一步创建一个区块结构体 1234567type Block struct &#123; //创建一个区块结构体 Timer int64 //时间戳 Data []byte //数据 prevHash []byte //前一个区块的哈希值 Hash []byte //本区块的哈希值&#125; 区块结构体创建完成，继续下一步 2：创建第一个区块 1234func Firstblosk() *Block &#123; //创建第一个区块信息，相当于一个创始块 firstblock := NewBlock("This is firstblock", []byte&#123;&#125;) //传入参数，返回结构体指针类型 return firstblock //返回的是结构体指针类型&#125; 123456789func NewBlock(data string, prevhash []byte) *Block &#123; //创建区块的函数 block1 := Block&#123;&#125; //创建一个区块结构体 block1.Timer = time.Now().Unix() //得到时间 block1.Data = []byte(data) //传入数据参数 block1.prevHash = prevhash //前一个哈希值为传入的数据 block1.setHash() //setHash 方法加密得到自己的hash return &amp;block1 //返回区块指针&#125; 用来创建第一个区块 3：给区块信息数据处理 123456func (block *Block) setHash() &#123; time := []byte(strconv.FormatInt(block.Timer, 10)) //将区块的时间转为字符切片类型，方便加密 heards := bytes.Join([][]byte&#123;time, block.Data, block.prevHash&#125;, []byte&#123;&#125;) //将时间，数据，前一个哈希拼接一下 hash := sha256.Sum256(heards) //用sha256包的Sum256函数加密 block.Hash = hash[:] //加密后的直接赋值给本哈希&#125; 4:主函数里面打印看一下本区块的哈希 //哈希用16进制打印 12345func main() &#123; firstblock := Firstblosk() fmt.Printf("%x",string(firstblock.Hash)) //16进制打印&#125; 这样一个简单的区块就创建成功了，我们把所有代码连接起来然后来看一下打印结果 123456789101112131415161718192021222324252627282930313233343536373839404142package main/*一个简单的区块创建实现*/import ( "time" "strconv" "bytes" "crypto/sha256" "fmt")type Block struct &#123; //创建一个区块结构体 Timer int64 //时间戳 Data []byte //数据 prevHash []byte //前一个区块的哈希值 Hash []byte //本区块的哈希值&#125;func (block *Block) setHash() &#123; time := []byte(strconv.FormatInt(block.Timer, 10)) //将区块的时间转为字符切片类型，方便加密 heards := bytes.Join([][]byte&#123;time, block.Data, block.prevHash&#125;, []byte&#123;&#125;) //将时间，数据，前一个哈希拼接一下 hash := sha256.Sum256(heards) //用sha256包的Sum256函数加密 block.Hash = hash[:] //加密后的直接赋值给本哈希&#125;func Firstblosk() *Block &#123; //创建第一个区块信息，相当于一个创始块 firstblock := NewBlock("This is firstblock", []byte&#123;&#125;) //传入参数，返回结构体指针类型 return firstblock //返回的是结构体指针类型&#125;func NewBlock(data string, prevhash []byte) *Block &#123; //创建区块的函数 block1 := Block&#123;&#125; //创建一个区块结构体 block1.Timer = time.Now().Unix() //得到时间 block1.Data = []byte(data) //传入数据参数 block1.prevHash = prevhash //前一个哈希值为传入的数据 block1.setHash() //setHash 方法加密得到自己的hash return &amp;block1 //返回区块指针&#125;func main() &#123; firstblock := Firstblosk() fmt.Printf("%x",string(firstblock.Hash)) //16进制打印&#125; 我们来看一下哈希打印结果 这样一个简单的区块就实现了，那么如果要实现一个简单的区块链呢？其实也按照这样的思路写下去也很容易实现，记住：区块链的本区块的哈希是下一个区块的前哈希，这样链接，下一章我们将讲解一个简单的区块链实现。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1%2F</url>
    <content type="text"><![CDATA[技术小白搭建个人博客 github+hexo本文主要讲解博客的搭建过程，next主题优化，next配置文件详解等。 不做过多介绍了，快速开始 准备安装软件依次安装 1、Node.js 2、Git 注册github访问https://github.com/ 右上角signup uername 最好都用小写，因为最后建立的博客地址是：http://username.github.io；邮箱十分重要，GitHub 上很多通知都是通过邮箱的。 创建Repository Repository 名字应该是http://username.github.io。比如我的username 就是wumansgy 其他的可以选择添加一些描述也可以选择默认什么也不添加 ，点击creat repository 配置和使用Github开始–所有应用–找到git bash 配置SSH keysssh keys就是用来使本地git 项目与github联系 1. 检查SSH keys的设置首先要检查自己电脑上现有的 SSH key： 1$ cd ~/. ssh 如果显示“No such file or directory”，说明这是你第一次使用 git 2、生成新的 SSH Key：123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 【提示1】这里的邮箱地址，输入注册 Github 的邮箱地址； 【提示2】「-C」的是大写的「C」 然后系统会要你输入密码： 12Enter passphrase (empty for no passphrase):&lt;设置密码&gt;Enter same passphrase again:&lt;再次输入密码&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有输入痕迹的，不要以为什么也没有输入。 最后看到这样的界面，就成功设置ssh key了： 3、添加SSH Key到GitHub在本地文件夹找到id_rsa.pub文件，看上面的图片第四行的位置告诉你存在哪里了 没找到的勾选一下文件扩展名 隐藏的项目 .ssh文件夹里记事本打开这个文件复制全部内容到 github相应位置。不要着急…（记得期末考试复习概率论看汤家凤老师的视频时老师的口头禅…） 你的github主页 点击头像后边的箭头（为什么我每次想要上传头像都没反应呢？希望有知道的小伙伴能看到告诉我一下） Title最好写，随便写。网上有说不写title也有可能后期出现乱七八糟的错误 Key部分就是放刚才复制的内容啦 点击Add SSH key 测试git bash 里 输入以下代码 不要改任何一个字 我就是自作聪明以为代表的是自己注册时候的邮箱然后… 1$ ssh -T git@github.com 如果得到以下反馈 123The authenticity of host &apos;GitHub.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no) 输入yes回车 1Enter passphrase for key &apos;/c/Users/lenovo/.ssh/id_rsa&apos;: 输入刚才设置的密码回车 设置用户信息现在已经可以通过 SSH 链接到 GitHub 啦!当然还需要完善一些个人信息: 12$ git config --global user.name &quot;wuyalan&quot;//输入注册时的username$ git config --global user.email &quot;alan.wyl@foxmail.com&quot;//填写注册邮箱 GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 SSH Key配置成功本机已成功连接到 github。 如有问题，请重新设置。常见错误请参考： 错误1 错误2 搭建hexo博客利用npm命令安装hexo 12$ cd$ npm install -g hexo 1. 创建独立博客项目文件夹 安装完成后，关掉前面那个 Git Bash 窗口。在本地创建一个与 Repository 中博客项目同名的文件夹（如E:[http://username.github.io]）在文件夹上点击鼠标右键，选择 Git bash here； 【提示】在进行博客搭建工作时，每次使用命令都要在 H:[http://username.github.io] 目录下。 执行下面的指令，Hexo 就会自动在 H:[http://username.github.io]文件夹建立独立博客所需要的所有文件啦！ 1$ hexo init 2. 安装依赖包 1$ npm install 3. 确保git部署 1$ npm install hexo-deployer-git --save 4.本地查看 现在已经搭建好本地的 Hexo 博客了，执行完下面的命令就可以到浏览器输入 localhost:4000 查看到啦 12$ hexo g$ hexo s hexo g 每次进行相应改动都要hexo g 生成一下 hexo s 启动服务预览 5. 用Hexo克隆主题 执行完 hexo init 命令后会给一个默认的主题：landscape 你可以到官网找你喜欢的主题进行下载 hexo themes 知乎：有哪些好看的 Hexo 主题？ 找到它所在的 Github Repository （怎么找，我喜欢的那个，恰好博主放了他的github地址，emmm） 找到之后通过git命令下载 在主题的repository点击clone 复制一下那个地址 1$ git clone +复制的地址+themes/archer 后面就是clone之后放到你本地的博客文件夹themes文件夹下 名字纹archer的文件 我下载的是archer主题~（有喜欢同样的小伙伴在个性化自己主题的时候欢迎来交流一下呀~真的是技术小白~还没研究清楚要怎么改，不过主题作者也会在readme说明的，细心看就是） 6. 修改整站配置文件 自己把 http://blog.io 中文件都点开看一遍，主要配置文件是 _config.yml ，可以用记事本打开，推荐使用 sublime 或者nodepad++打开。 修订清单如下，文档内有详细注释，可按注释逐个修订 博客名字及作者信息：_config.yml 个人介绍页面：about.md 代表作页面：milestone.md 博客参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889这里贴一份网上看到的 可以复制替换原来的 但是替换之前最好备份 可能会出错那要么你就对照着看一下改就好# Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客title: My Blog #博客名subtitle: to be continued... #副标题description: My blog #给搜索引擎看的，对网站的描述，可以自定义author: Yourname #作者，在博客底部可以看到email: yourname@yourmail.com #你的联系邮箱language: zh-CN #中文。如果不填则默认英文# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categories# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecasemax_open_file: 100filename_case: 0highlight: enable: true backtick_code_block: true line_number: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server 不修改## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: falselogger_format:# Date / Time format 日期格式，可以修改成自己喜欢的格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-M-Dtime_format: H:mm:ss# Pagination 每页显示文章数，可以自定义，贴主设置的是10## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions 这里配置站点所用主题和插件，暂时默认## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: landscapeexclude_generator:plugins:- hexo-generator-feed- hexo-generator-sitemap# Deployment 站点部署到github要配置## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: git repository: branch: master 7. 启用新下载的主题 在刚打开的的_config.yml 文件中，找到“# Extensions”，把默认主题 landscape 修改为刚刚下载下来的主题名： 【提示】http://username.github.io 里有两个 config.yml 文件，一个在根目录，一个在 theme 下，现在修改的是在根目录下的。 8. 更新主题 git bash 里执行 12$ cd themes/主题名$ git pull 9. 本地查看调试 每次修改都要hexo g 生成一下 12$ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试，退出服务用Ctrl+c 浏览器输入 localhost：4000 预览效果 将博客部署到http://username.github.io1. 复制SSH码进入 Github 个人主页中的 Repository，复制新建的独立博客项目:http://username.github.io 的 SSH 码 2. 编辑整站配置文件打开 H:\username.github.io_config.yml,把刚刚复制的 SSH 码粘贴到“repository：”后面，别忘了冒号后要空一格。 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 3. 执行下列指令即可完成部署。【提示】每次修改本地文件后，需要 hexo g 才能保存。每次使用命令时，都要在你的博客文件夹目录下 12$ hexo g$ hexo d （ps：我在第一次hexo d 的时候出现了错误，具体错误提示忘了，原因是我没有deploy 的权限 在repository的setting （这里我有一点小疑惑 为什么delete不了这个公钥呢，我想要delete是因为第一次设置时没有勾选 ..如下 emm里面的内容就是重复配置SSH key的步骤，记得勾选这个小框框，我就是没有勾选设置之后还是没有deploy成功 ） 因为我看到的教程里大多数没有讲这一部分，所以我也不确定这一步是否必须，如果有遇到相同问题的小伙伴可以参考 ） 【提示】如果在配置 SSH key 时设置了密码，执行 hexo d 命令上传文件时需要输入密码进行确认，会出现一个小框框。 输入密码之后在浏览器输入： username.github.io 如果得到你想要的效果，那么恭喜你，博客已经搭建好啦！ 允许你偷偷激动一下…哈哈哈 之后就是写博文了，我还没开始…要好好写博客好好写博客 你看技术大神们哪个没有自己的优秀博客。 不懂技术的小伙伴也可以在自己的小天地写文，很爽又很有逼格是不是~ 我的博客地址：进入 next主题使用及优化启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 选择 Pisces Scheme 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-CN Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 文章模块的美化文章内代码美化 行内代码在主题目录下，将source/css/_custom/custom.styl文件修改如下： 123456789//行内代码样式code &#123; color: #ff7600; background: #fbf7f8; border: 1px solid #d6d6d6; padding:1px 4px; word-break: break-all; border-radius:4px;&#125; 区块代码在主题目录下，修改config.yml文件： 12# 样式可选： normal | night | night eighties | night blue | night brighthighlight_theme: night 文章结束语 添加模块文件 在主题目录下layout/_macro中新建 passage-end-tag.swig文件,并添加以下内容： 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt; -------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读------------- &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 导入模板文件 在layout/_macro/post.swig文件中，找到： 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在上面代码之前添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 配置在主题配置文件中添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 增强文章底部版权信息 增加文章md文件的头部信息中添加copyright: true时，添加版权声明 增加文章标题、发布时间、更新时间等信息 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。 微信：sgsgy5 qq:869087033 欢迎交流，搭建走了很多坑。 友情链接 参考： 技术小白搭建hexo+github博客 next最新版主题下载使用 next主题官方文档 next主题个性化教程 next主题配置文件详解 NexT v6.0+ 背景动画Canvas_nest设置无效的解决方案 给Hexo搭建的博客增加百度谷歌搜索引擎验证 添加文章字数和读取文章的时间 hexo + next主题高级配置 关于博客图片上传方法]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言简单排序之冒泡和插入排序]]></title>
    <url>%2F2018%2F09%2F01%2Fgo%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E5%92%8C%E6%8F%92%E5%8F%991%2F</url>
    <content type="text"><![CDATA[编程即数学，在编程中也会遇到很多的数学问题的集合，今天我们来讲解一下编程中最常见的冒泡排序，以及冒泡排序之后的插入排序 1：冒泡排序：见名知意，冒泡在我们生活当中可以有哪些常见的事物呢，比如在生活当中，大家都见到过烧开水的状态，那么水中的气泡就会不断的往上面漂浮，应用物理学上的知识来讲就是气泡的质量比较轻，在水中有浮力，就会不断的上浮，那么我们应该怎样应用到编程中的冒泡排序呢，我们先来看一段代码，然后慢慢分析 12345678910111213141516171819package mainimport "fmt"//func main() &#123; arr := [10]int&#123;9, 1, 5, 6, 3, 7, 10, 8, 2, 4&#125; //先定义一个乱序数组 //冒泡排序 for i := 0; i &lt; 10-1; i++ &#123; //外面的循环用来循环次数 for j := 0; j &lt; 10-1-i; j++ &#123; //里面的循环用来循环 每次对比到哪里 if arr[j] &gt; arr[j+1] &#123; //数据交换 arr[j], arr[j+1] = arr[j+1], arr[j] //go语言的多个数据交换格式 //temp := arr[j] //普通数据交换格式 //arr[j] = arr[j+1] //arr[j+1] = temp &#125; &#125; &#125; fmt.Println(arr)&#125; 我们看到这个代码和这张图片，在图片中我们只写了前面几次，先来看第一次，第一个元素和第二个相比4比2大，如果第一个元素比第二个大那么就交换一下，然后第二个元素和第三个相比，如果大就交换，然后第三第四相比，第四第五相比，一直比到最后一个和倒数第一个，有没有发现这样比一次就能确定一个最大的数，而且最大的数是放在最后一个元素里面的，这样一次就是外面的外循环 1for i := 0; i &lt; 10-1; i++ &#123; //这句话就是外面的循环 然后确定第一个最大的放最后一个，那么我们然后怎么办呢 ，然后我们当然继续下一次对比然后再确定一个第二大的放在倒数第二的位置啊，最大的确定下来后，我们继续从第一个开始遍历，但是这次遍历要注意了，不需要遍历到最后一个元素，而只需遍历到倒数第二个就行了，这是为什么呢，因为最后一个元素已经确定下来是最大的了，所以就不需要对比了，我们来看内循环 12for j := 0; j &lt; 10-1-i; j++ &#123; //里面的循环用来循环 每次对比到哪里//这里的判断条件是 小于10-1-i，i是什么呢，就是外循环的次数，所以只需要对比到10-1-i就行 然后内循环每次对比相邻的两个元素，如果前面大于后面的那么就交换， 12345//数据交换 arr[j], arr[j+1] = arr[j+1], arr[j] //go语言的多个数据交换格式 //temp := arr[j] //普通数据交换格式 //arr[j] = arr[j+1] //arr[j+1] = temp 这里面数据交换 有两种格式，第一种就是GO语言里面的简单交换格式，第二种是常见的交换数据格式，需要定义一个临时变量 然后可以打印出来数组，就变成从小到大的升序数组了， 那么如果要变成降序排序怎么改呢？ 来看这句话 1if arr[j] &gt; arr[j+1] &#123; 我们只需要把这里的大于号改成小于号就行啦 不喜勿喷，谢谢哈哈插入排序后续]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>排序问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言中的面向对象，接口类型，工厂设计模式解读]]></title>
    <url>%2F2018%2F09%2F01%2Fgo%E8%AF%AD%E8%A8%80%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式： 定义一个用于创建对象的接口，让子类决定实例化哪一个类抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类个人觉得这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。工厂方法模式 抽象工厂模式针对的是一个产品等级结构 针对的是面向多个产品等级结构一个抽象产品类 多个抽象产品类可以派生出多个具体产品类 每个抽象产品类可以派生出多个具体产品类一个抽象工厂类，可以派生出多个具体工厂类 一个抽象工厂类，可以派生出多个具体工厂类每个具体工厂类只能创建一个具体产品类的实例 每个具体工厂类可以创建多个具体产品类的实例加减乘除四则运算器工厂模式举例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport "fmt"type operation struct&#123; //定义一个父类两个数据 num1 float64 num2 float64&#125;type operationAdd struct&#123; //加法子类 operation&#125;func (op *operationAdd)getresult()float64&#123; //加法类的方法 return op.num1+op.num2&#125;type operationSub struct&#123; //减法子类 operation&#125;func (sub *operationSub)getresult()float64&#123; //减法类的方法 return sub.num1-sub.num2&#125;type operationMult struct&#123; //乘法子类 operation&#125;func (mult *operationMult)getresult()float64&#123; return mult.num1*mult.num2&#125;type operationDivi struct&#123; operation&#125; //除法子类func (divi *operationDivi)getresult()float64&#123; return divi.num1/divi.num2&#125;type operationer interface&#123; //定义接口 getresult() float64 //加法的方法&#125;type operationfactor struct &#123; //operation //用于创建对象的类，工厂模式&#125;func (op *operationfactor)creatoperation(ope string,num1 float64,num2 float64)float64&#123; //用于构件对象类 var result float64 switch ope &#123; case "+": add:=&amp;operationAdd&#123;operation&#123;num1,num2&#125;&#125; //按照传过来的符号来创建相应的对象 result=operationwho(add) //传递给多态的函数，直接调用 case "-": sub:=&amp;operationSub&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(sub) case "*": mult:=&amp;operationMult&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(mult) case "/": divi:=&amp;operationDivi&#123;operation&#123;num1,num2&#125;&#125; result=operationwho(divi) &#125; return result&#125;func operationwho(i operationer)float64&#123; return i.getresult() //此处为创建一个多态的函数&#125;func main()&#123; //m:=&amp;operationAdd&#123;operation&#123;3,4&#125;&#125; //var iop operationer //iop=m //sum:=iop.getresult() //fmt.Println(sum) var op1 operationfactor //直接创建工厂类对象 sum:=op1.creatoperation("+",9,6) //直接调用工厂类的方法 fmt.Println(sum) var op2 operationfactor sub:=op2.creatoperation("-",9,8) fmt.Println(sub) var op3 operationfactor mult:=op3.creatoperation("*",3,4) fmt.Println(mult) var op4 operationfactor div:=op4.creatoperation("/",9,10) fmt.Println(div)&#125; 在上面的例子当中，如果对面向对象没有接触的话可能会有一些不好理解，在go语言当中面向对象可能和别的语言有一些不同，go语言是利用匿名字段来实现继承，在上面的例子中多态函数的实现可以让函数调用更加方便，比如每个结构体类都有10几个甚至更多的函数，那么直接都把这些函数封装在多态的函数里面，那么每次调用直接传递一个结构体类给多态函数就直接全部调用了，这样就是很方便的]]></content>
      <categories>
        <category>GO语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
</search>
